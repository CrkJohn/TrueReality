osgViewer::CompositeViewer
osgViewer::GraphicsWindow
osgViewer::StatsHandler
osgViewer::View
osgViewer::Viewer
osgViewer::Viewer::CullThreadPerCameraDrawThreadPerContext
osgViewer::Viewer::SingleThreaded
osgViewer::Viewer::Windows
osgViewer::Viewer::Windows::iterator
osgViewer::ViewerBase::Contexts

osgUtil::CullVisitor
osgUtil::LineSegmentIntersector
osgUtil::LineSegmentIntersector::Intersections
osgUtil::LineSegmentIntersector::Intersections::iterator
osgUtil::Optimizer
osgUtil::Optimizer::FlattenStaticTransformsVisitor
osgUtil::Optimizer::REMOVE_LOADED_PROXY_NODES
osgUtil::Optimizer::REMOVE_REDUNDANT_NODES
osgUtil::Optimizer::SHARE_DUPLICATE_STATE
osgUtil::Simplifier
osgUtil::SceneView::VariablesMask::ALL_VARIABLES
osgUtil::SceneView::VariablesMask::CULL_MASK
osgUtil::SmoothingVisitor

osgText::Font
osgText::readFontFile
osgText::Text
osgText::Text::AlignmentType
osgText::Text::LEFT_CENTER
osgText::Text::REVERSED_YZ_PLANE
osgText::Text::SCREEN
osgText::Text::SCREEN_COORDS
osgText::TextBase::CENTER_CENTER

osgSim::DOFTransform
osgSim::MultiSwitch
osgSim::LightPointNode

osgParticle::Emitter
osgParticle::FluidProgram
osgParticle::ModularEmitter
osgParticle::ModularProgram
osgParticle::ParticleSystem
osgParticle::ParticleSystemUpdater
osgParticle::ParticleProcessor::ABSOLUTE_RF
osgParticle::Program

osgGA::CameraManipulator
osgGA::GUIActionAdapter
osgGA::GUIEventAdapter
osgGA::GUIEventAdapter::DRAG
osgGA::GUIEventAdapter::FRAME
osgGA::GUIEventAdapter::KEYUP
osgGA::GUIEventAdapter::KEYDOWN
osgGA::GUIEventAdapter::KEY_Control_R
osgGA::GUIEventAdapter::KEY_Shift_R
osgGA::GUIEventAdapter::KEY_Minus
osgGA::GUIEventAdapter::KEY_F1
osgGA::GUIEventAdapter::MODKEY_ALT
osgGA::GUIEventAdapter::MODKEY_SHIFT
osgGA::GUIEventAdapter::PUSH
osgGA::GUIEventHandler
osgGA::TrackballManipulator

osgDB::Archive
osgDB::ArchiveExtended
osgDB::CASE_INSENSITIVE
osgDB::concatPaths
osgDB::DIRECTORY
osgDB::FileType
osgDB::findDataFile
osgDB::findFileInDirectory
osgDB::getFileExtensionIncludingDot
osgDB::getFileExtension
osgDB::getFilePath
osgDB::getSimpleFileName
osgDB::getStrippedName
osgDB::Options
osgDB::Options::CACHE_ALL
osgDB::readImageFile
osgDB::readNodeFile
osgDB::ReaderWriter::Options
osgDB::ReaderWriter::Options::CACHE_IMAGES
osgDB::ReaderWriter::ReaderWriter::Options
osgDB::ReaderWriter::ReadResult
osgDB::ReaderWriter::READ
osgDB::ReaderWriter::WriteResult
osgDB::Registry::ArchiveExtensionList
osgDB::Registry::ArchiveExtensionList::const_iterator iter
osgDB::Registry::instance
osgDB::REGULAR_FILE
osgDB::SharedStateManager
osgDB::writeImageFile
osgDB::writeNodeFile

osg::AlphaFunc
osg::AlphaFunc::GEQUAL
osg::ArgumentParser
osg::Array::BIND_OVERALL 
osg::Billboard
osg::Billboard::AXIAL_ROT
osg::BlendFunc
osg::BoundingBox
osg::BoundingSphere
osg::Camera::DrawCallback
osg::Camera
osg::Camera::FRAME_BUFFER
osg::clampBetween
osg::ClipPlane
osg::ClipNode
osg::clone
osg::CollectParentPaths
osg::componentMultiply
osg::ComputeBoundsVisitor
osg::computeLocalToWorld
osg::CopyOp
osg::CopyOp::SHALLOW_COPY
osg::CullSettings::DO_NOT_COMPUTE_NEAR_FAR
osg::DegreesToRadians
osg::Depth
osg::Drawable
osg::Drawable::Drawable::UpdateCallback
osg::DrawArrays
osg::DrawElementsUInt
osg::DrawElementsUShort
osg::equivalent
osg::FloatArray(array_size);
osg::Geode
osg::Geometry::BIND_OVERALL
osg::Geometry::PrimitiveSetList
osg::Geometry::PrimitiveSetList::iterator
osg::GL2Extensions
osg::GraphicsContext
osg::GraphicsContext::Traits
osg::Group
osg::Image
osg::inDegrees
osg::isNaN
osg::LightSource
osg::LOD
osg::LOD::DISTANCE_FROM_EYE_POINT
osg::Material
osg::Material::FRONT_AND_BACK
osg::Matrix
osg::Matrixd
osg::Matrixf
osg::MatrixTransform
osg::Node
osg::Node::ParentList::iterator
osg::NodePath
osg::NOTICE
osg::notify
osg::NotifySeverity::WARN
osg::NodeCallback
osg::NodeVisitor
osg::NodeVisitor::TRAVERSE_ALL_CHILDREN
osg::Object
osg::Object::STATIC
osg::Operation
osg::Plane
osg::PolygonOffset
osg::Polytope
osg::PrimitiveSet
osg::PrimitiveSet::QUADS
osg::PrimitiveSet::TRIANGLE_STRIP
osg::Program
osg::ProxyNode
osg::Quat
osg::QueryGeometry
osg::RadiansToDegrees
osg::Referenced
osg::RefMatrix
osg::ref_ptr
osg::RenderInfo
osg::setNotifyLevel
osg::sign
osg::Shader
osg::Shader::FRAGMENT
osg::Shader::VERTEX
osg::ShapeDrawable
osg::Sphere
osg::State
osg::StateAttribute::BLENDFUNC
osg::StateAttribute::GLModeValue
osg::StateAttribute::ON
osg::StateAttribute::TEXTURE
osg::StateSet
osg::StateSet::TRANSPARENT_BIN
osg::StateSet::USE_RENDERBIN_DETAILS
osg::Stencil
osg::Switch
osg::TessellationHints
osg::TexEnv
osg::TexEnv::MODULATE
osg::TexMat
osg::Texture
osg::Texture::InternalFormatMode
osg::Texture::USE_IMAGE_DATA_FORMAT
osg::Texture::USE_S3TC_DXT5_COMPRESSION
osg::Texture::REPEAT
osg::Texture::WRAP_S
osg::TextureCubeMap
osg::TextureRectangle::MIN_FILTER
osg::Texture2D
osg::Texture3D
osg::Timer
osg::Timer_t 
osg::Transform::ABSOLUTE_RF
osg::Uniform
osg::Uniform::BOOL
osg::Uniform::FLOAT
osg::Vec2
osg::Vec2Array
osg::Vec3
osg::Vec3Array
osg::Vec3f
osg::Vec4
osg::Vec4Array
osg::Vec4f
osg::Viewport






	Line 15:     osg::ref_ptr<osg::GraphicsContext::Traits> traits = new osg::GraphicsContext::Traits;
	Line 15:     osg::ref_ptr<osg::GraphicsContext::Traits> traits = new osg::GraphicsContext::Traits;
	Line 15:     osg::ref_ptr<osg::GraphicsContext::Traits> traits = new osg::GraphicsContext::Traits;
	Line 25:     _gc = osg::GraphicsContext::createGraphicsContext(traits.get());
	Line 30:         _gc = osg::GraphicsContext::createGraphicsContext(traits.get());
  D:\Development\psim\src\subview\SkydomeGraphicsContext.h (2 hits)
	Line 22:     osg::ref_ptr<osg::GraphicsContext> _gc;
	Line 22:     osg::ref_ptr<osg::GraphicsContext> _gc;
  D:\Development\psim\src\subview\SkydomeUtils.cpp (106 hits)
	Line 29: osg::ref_ptr<osg::Geode> SkydomeUtils::createScreenQuadInstances(float width, float height, int numInstances)
	Line 29: osg::ref_ptr<osg::Geode> SkydomeUtils::createScreenQuadInstances(float width, float height, int numInstances)
	Line 31:     const osg::Vec3 corner = osg::Vec3(0., 0., 0.);
	Line 31:     const osg::Vec3 corner = osg::Vec3(0., 0., 0.);
	Line 32:     const osg::Vec3 widthVec = osg::Vec3(width, 0.0f, 0.0f);
	Line 32:     const osg::Vec3 widthVec = osg::Vec3(width, 0.0f, 0.0f);
	Line 33:     const osg::Vec3 heightVec = osg::Vec3(0.0f, height, 0.0f);
	Line 33:     const osg::Vec3 heightVec = osg::Vec3(0.0f, height, 0.0f);
	Line 38:     osg::ref_ptr<osg::Geometry> geom = new osg::Geometry();
	Line 38:     osg::ref_ptr<osg::Geometry> geom = new osg::Geometry();
	Line 38:     osg::ref_ptr<osg::Geometry> geom = new osg::Geometry();
	Line 40:     osg::Vec3Array* coords = new osg::Vec3Array(4);
	Line 40:     osg::Vec3Array* coords = new osg::Vec3Array(4);
	Line 47:     osg::Vec2Array* tcoords = new osg::Vec2Array(4);
	Line 47:     osg::Vec2Array* tcoords = new osg::Vec2Array(4);
	Line 54:     osg::Vec4Array* colours = new osg::Vec4Array(1);
	Line 54:     osg::Vec4Array* colours = new osg::Vec4Array(1);
	Line 57:     geom->setColorBinding(osg::Geometry::BIND_OVERALL);
	Line 59:     osg::Vec3Array* normals = new osg::Vec3Array(1);
	Line 59:     osg::Vec3Array* normals = new osg::Vec3Array(1);
	Line 63:     geom->setNormalBinding(osg::Geometry::BIND_OVERALL);
	Line 65:     geom->addPrimitiveSet(new osg::DrawArrays(osg::PrimitiveSet::QUADS, 0, 4, numInstances));
	Line 65:     geom->addPrimitiveSet(new osg::DrawArrays(osg::PrimitiveSet::QUADS, 0, 4, numInstances));
	Line 67:     geom->setStateSet(new osg::StateSet());
	Line 70:     osg::ref_ptr<osg::StateSet> stateSet = geom->getOrCreateStateSet();
	Line 70:     osg::ref_ptr<osg::StateSet> stateSet = geom->getOrCreateStateSet();
	Line 71:     stateSet->setMode(GL_DEPTH_TEST, osg::StateAttribute::OFF);
	Line 72:     osg::ref_ptr<osg::Geode> screenQuadGeode = new osg::Geode();
	Line 72:     osg::ref_ptr<osg::Geode> screenQuadGeode = new osg::Geode();
	Line 72:     osg::ref_ptr<osg::Geode> screenQuadGeode = new osg::Geode();
	Line 78: osg::Geode* SkydomeUtils::createScreenQuad(int width, int height, osg::Texture* tex, osg::Program* prog)
	Line 78: osg::Geode* SkydomeUtils::createScreenQuad(int width, int height, osg::Texture* tex, osg::Program* prog)
	Line 78: osg::Geode* SkydomeUtils::createScreenQuad(int width, int height, osg::Texture* tex, osg::Program* prog)
	Line 80:     osg::Geometry* quadGeom = osg::createTexturedQuadGeometry(osg::Vec3(),
	Line 80:     osg::Geometry* quadGeom = osg::createTexturedQuadGeometry(osg::Vec3(),
	Line 80:     osg::Geometry* quadGeom = osg::createTexturedQuadGeometry(osg::Vec3(),
	Line 81:             osg::Vec3(width, 0.0f, 0.0f),
	Line 82:             osg::Vec3(0.0f, height, 0.0f));
	Line 83:     quadGeom->setStateSet(new osg::StateSet());
	Line 85:     osg::StateSet* stateSet = quadGeom->getOrCreateStateSet();
	Line 86:     stateSet->setMode(GL_DEPTH_TEST, osg::StateAttribute::OFF);
	Line 88:     osg::Geode* screenQuadGeode = new osg::Geode();
	Line 88:     osg::Geode* screenQuadGeode = new osg::Geode();
	Line 93:         osg::Uniform* texUniform = new osg::Uniform(osg::Uniform::SAMPLER_2D, "inputImage");
	Line 93:         osg::Uniform* texUniform = new osg::Uniform(osg::Uniform::SAMPLER_2D, "inputImage");
	Line 93:         osg::Uniform* texUniform = new osg::Uniform(osg::Uniform::SAMPLER_2D, "inputImage");
	Line 96:         screenQuadGeode->getOrCreateStateSet()->setTextureAttributeAndModes(0, tex, osg::StateAttribute::ON);
	Line 101:         quadGeom->getOrCreateStateSet()->setAttribute(prog, osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);
	Line 101:         quadGeom->getOrCreateStateSet()->setAttribute(prog, osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);
	Line 107: osg::Texture2D* SkydomeUtils::createRTTTarget(int width, int height, GLint internalFormat,
	Line 108:         osg::Texture::FilterMode minFilter, osg::Texture::FilterMode magFilter,
	Line 108:         osg::Texture::FilterMode minFilter, osg::Texture::FilterMode magFilter,
	Line 109:         osg::Texture::WrapMode wrapS, osg::Texture::WrapMode wrapT,
	Line 109:         osg::Texture::WrapMode wrapS, osg::Texture::WrapMode wrapT,
	Line 110:         osg::Texture::WrapMode wrapR)
	Line 112:     osg::Texture2D* rttTarget = new osg::Texture2D;
	Line 112:     osg::Texture2D* rttTarget = new osg::Texture2D;
	Line 114:     rttTarget->setInternalFormat(/*osg::Texture::USE_IMAGE_DATA_FORMAT*/GL_RGB16F_ARB); //GL_RGBA
	Line 115:     rttTarget->setFilter(osg::Texture2D::MIN_FILTER, minFilter);
	Line 116:     rttTarget->setFilter(osg::Texture2D::MAG_FILTER, magFilter);
	Line 118:     rttTarget->setWrap(osg::Texture::WRAP_S, wrapS);
	Line 119:     rttTarget->setWrap(osg::Texture::WRAP_T, wrapT);
	Line 120:     //    rttTarget->setWrap(osg::Texture::WRAP_R, wrapR);
	Line 122:     osg::Image* image = new osg::Image;
	Line 122:     osg::Image* image = new osg::Image;
	Line 129: osg::ref_ptr<osg::Texture3D> SkydomeUtils::createRTTTarget(int width, int height, int depth, GLint internalFormat,
	Line 129: osg::ref_ptr<osg::Texture3D> SkydomeUtils::createRTTTarget(int width, int height, int depth, GLint internalFormat,
	Line 130:         osg::Texture::FilterMode minFilter, osg::Texture::FilterMode magFilter,
	Line 130:         osg::Texture::FilterMode minFilter, osg::Texture::FilterMode magFilter,
	Line 131:         osg::Texture::WrapMode wrapS, osg::Texture::WrapMode wrapT,
	Line 131:         osg::Texture::WrapMode wrapS, osg::Texture::WrapMode wrapT,
	Line 132:         osg::Texture::WrapMode wrapR)
	Line 134:     osg::ref_ptr<osg::Texture3D> rttTarget = new osg::Texture3D();
	Line 134:     osg::ref_ptr<osg::Texture3D> rttTarget = new osg::Texture3D();
	Line 134:     osg::ref_ptr<osg::Texture3D> rttTarget = new osg::Texture3D();
	Line 137:     rttTarget->setFilter(osg::Texture2D::MIN_FILTER, minFilter);
	Line 138:     rttTarget->setFilter(osg::Texture2D::MAG_FILTER, magFilter);
	Line 140:     rttTarget->setWrap(osg::Texture::WRAP_S, wrapS);
	Line 141:     rttTarget->setWrap(osg::Texture::WRAP_T, wrapT);
	Line 142:     rttTarget->setWrap(osg::Texture::WRAP_R, wrapR);
	Line 144:     osg::ref_ptr<osg::Image> image = new osg::Image;
	Line 144:     osg::ref_ptr<osg::Image> image = new osg::Image;
	Line 144:     osg::ref_ptr<osg::Image> image = new osg::Image;
	Line 151: osg::Camera* SkydomeUtils::createRTTCamera(int width, int height)
	Line 153:     osg::ref_ptr<osg::Camera> rttCamera = new osg::Camera();
	Line 153:     osg::ref_ptr<osg::Camera> rttCamera = new osg::Camera();
	Line 153:     osg::ref_ptr<osg::Camera> rttCamera = new osg::Camera();
	Line 156:     rttCamera->setProjectionMatrix(osg::Matrix::ortho2D(0, width, 0, height));
	Line 157:     rttCamera->setReferenceFrame(osg::Transform::ABSOLUTE_RF);
	Line 158:     rttCamera->setViewMatrix(osg::Matrix::identity());
	Line 159:     rttCamera->setClearColor(osg::Vec4(.7f, 0.1f, 0.0f, 1.0f));
	Line 161:     rttCamera->setRenderOrder(osg::Camera::PRE_RENDER);
	Line 162:     rttCamera->setRenderTargetImplementation(osg::Camera::FRAME_BUFFER_OBJECT);
	Line 167: RTTPair SkydomeUtils::createRTTPair(int width, int height, osg::Program* program, GLint internalFormat,
	Line 168:         osg::Texture::FilterMode minFilter, osg::Texture::FilterMode magFilter,
	Line 168:         osg::Texture::FilterMode minFilter, osg::Texture::FilterMode magFilter,
	Line 169:         osg::Texture::WrapMode wrapS, osg::Texture::WrapMode wrapT,
	Line 169:         osg::Texture::WrapMode wrapS, osg::Texture::WrapMode wrapT,
	Line 170:         osg::Texture::WrapMode wrapR)
	Line 172:     osg::ref_ptr<osg::Texture2D> tex = createRTTTarget(width, height, internalFormat, minFilter, magFilter,
	Line 172:     osg::ref_ptr<osg::Texture2D> tex = createRTTTarget(width, height, internalFormat, minFilter, magFilter,
	Line 174:     osg::ref_ptr<osg::Camera> cam = createRTTCamera(width, height);
	Line 174:     osg::ref_ptr<osg::Camera> cam = createRTTCamera(width, height);
	Line 176:     cam->attach(osg::Camera::COLOR_BUFFER, tex);
	Line 179:         cam->getOrCreateStateSet()->setAttribute(program, osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);
	Line 179:         cam->getOrCreateStateSet()->setAttribute(program, osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);
  D:\Development\psim\src\subview\SkydomeUtils.h (40 hits)
	Line 22: typedef std::pair<osg::Camera*, osg::ref_ptr<osg::Texture> > RTTPair;
	Line 22: typedef std::pair<osg::Camera*, osg::ref_ptr<osg::Texture> > RTTPair;
	Line 22: typedef std::pair<osg::Camera*, osg::ref_ptr<osg::Texture> > RTTPair;
	Line 23: typedef std::pair<osg::ref_ptr<osg::Texture>, char*> TextureAttachment;
	Line 23: typedef std::pair<osg::ref_ptr<osg::Texture>, char*> TextureAttachment;
	Line 40:     static osg::ref_ptr<osg::Geode> createScreenQuadInstances(float width, float height, int numInstances);
	Line 40:     static osg::ref_ptr<osg::Geode> createScreenQuadInstances(float width, float height, int numInstances);
	Line 42:     static osg::Geode* createScreenQuad(int width, int height, osg::Texture* tex = NULL, osg::Program* prog = NULL);
	Line 42:     static osg::Geode* createScreenQuad(int width, int height, osg::Texture* tex = NULL, osg::Program* prog = NULL);
	Line 42:     static osg::Geode* createScreenQuad(int width, int height, osg::Texture* tex = NULL, osg::Program* prog = NULL);
	Line 44:     static osg::Texture2D* createRTTTarget(int width, int height, GLint internalFormat,
	Line 45:                                            osg::Texture::FilterMode minFilter, osg::Texture::FilterMode magFilter,
	Line 45:                                            osg::Texture::FilterMode minFilter, osg::Texture::FilterMode magFilter,
	Line 46:                                            osg::Texture::WrapMode wrapS, osg::Texture::WrapMode wrapT,
	Line 46:                                            osg::Texture::WrapMode wrapS, osg::Texture::WrapMode wrapT,
	Line 47:                                            osg::Texture::WrapMode wrapR);
	Line 49:     static osg::ref_ptr<osg::Texture3D> createRTTTarget(int width, int height, int depth, GLint internalFormat = GL_RGB16F_ARB,
	Line 49:     static osg::ref_ptr<osg::Texture3D> createRTTTarget(int width, int height, int depth, GLint internalFormat = GL_RGB16F_ARB,
	Line 50:                                                         osg::Texture::FilterMode minFilter = osg::Texture2D::LINEAR, osg::Texture::FilterMode magFilter = osg::Texture2D::LINEAR,
	Line 50:                                                         osg::Texture::FilterMode minFilter = osg::Texture2D::LINEAR, osg::Texture::FilterMode magFilter = osg::Texture2D::LINEAR,
	Line 50:                                                         osg::Texture::FilterMode minFilter = osg::Texture2D::LINEAR, osg::Texture::FilterMode magFilter = osg::Texture2D::LINEAR,
	Line 50:                                                         osg::Texture::FilterMode minFilter = osg::Texture2D::LINEAR, osg::Texture::FilterMode magFilter = osg::Texture2D::LINEAR,
	Line 51:                                                         osg::Texture::WrapMode wrapS = osg::Texture::CLAMP_TO_EDGE, osg::Texture::WrapMode wrapT = osg::Texture::CLAMP_TO_EDGE,
	Line 51:                                                         osg::Texture::WrapMode wrapS = osg::Texture::CLAMP_TO_EDGE, osg::Texture::WrapMode wrapT = osg::Texture::CLAMP_TO_EDGE,
	Line 51:                                                         osg::Texture::WrapMode wrapS = osg::Texture::CLAMP_TO_EDGE, osg::Texture::WrapMode wrapT = osg::Texture::CLAMP_TO_EDGE,
	Line 51:                                                         osg::Texture::WrapMode wrapS = osg::Texture::CLAMP_TO_EDGE, osg::Texture::WrapMode wrapT = osg::Texture::CLAMP_TO_EDGE,
	Line 52:                                                         osg::Texture::WrapMode wrapR = osg::Texture::CLAMP_TO_EDGE);
	Line 52:                                                         osg::Texture::WrapMode wrapR = osg::Texture::CLAMP_TO_EDGE);
	Line 54:     static osg::Camera* createRTTCamera(int width, int height);
	Line 56:     static RTTPair createRTTPair(int width, int height, osg::Program* program = NULL, GLint internalFormat = GL_RGBA,
	Line 57:                                  osg::Texture::FilterMode minFilter = osg::Texture2D::LINEAR, osg::Texture::FilterMode magFilter = osg::Texture2D::LINEAR,
	Line 57:                                  osg::Texture::FilterMode minFilter = osg::Texture2D::LINEAR, osg::Texture::FilterMode magFilter = osg::Texture2D::LINEAR,
	Line 57:                                  osg::Texture::FilterMode minFilter = osg::Texture2D::LINEAR, osg::Texture::FilterMode magFilter = osg::Texture2D::LINEAR,
	Line 57:                                  osg::Texture::FilterMode minFilter = osg::Texture2D::LINEAR, osg::Texture::FilterMode magFilter = osg::Texture2D::LINEAR,
	Line 58:                                  osg::Texture::WrapMode wrapS = osg::Texture::CLAMP_TO_EDGE, osg::Texture::WrapMode wrapT = osg::Texture::CLAMP_TO_EDGE,
	Line 58:                                  osg::Texture::WrapMode wrapS = osg::Texture::CLAMP_TO_EDGE, osg::Texture::WrapMode wrapT = osg::Texture::CLAMP_TO_EDGE,
	Line 58:                                  osg::Texture::WrapMode wrapS = osg::Texture::CLAMP_TO_EDGE, osg::Texture::WrapMode wrapT = osg::Texture::CLAMP_TO_EDGE,
	Line 58:                                  osg::Texture::WrapMode wrapS = osg::Texture::CLAMP_TO_EDGE, osg::Texture::WrapMode wrapT = osg::Texture::CLAMP_TO_EDGE,
	Line 59:                                  osg::Texture::WrapMode wrapR = osg::Texture::CLAMP_TO_EDGE);
	Line 59:                                  osg::Texture::WrapMode wrapR = osg::Texture::CLAMP_TO_EDGE);
  D:\Development\psim\src\subview\SmokeStacks.cpp (38 hits)
	Line 41:     mStateSet = new osg::StateSet;
	Line 44:     osg::ref_ptr<osg::Image> img;
	Line 44:     osg::ref_ptr<osg::Image> img;
	Line 47:     mTexture = new osg::Texture2D;
	Line 49:     mTexture->setWrap(osg::Texture::WRAP_S, osg::Texture::CLAMP);
	Line 49:     mTexture->setWrap(osg::Texture::WRAP_S, osg::Texture::CLAMP);
	Line 50:     mTexture->setWrap(osg::Texture::WRAP_T, osg::Texture::CLAMP);
	Line 50:     mTexture->setWrap(osg::Texture::WRAP_T, osg::Texture::CLAMP);
	Line 51:     mTexture->setFilter(osg::Texture2D::MIN_FILTER, osg::Texture2D::LINEAR_MIPMAP_LINEAR);
	Line 51:     mTexture->setFilter(osg::Texture2D::MIN_FILTER, osg::Texture2D::LINEAR_MIPMAP_LINEAR);
	Line 52:     mTexture->setFilter(osg::Texture2D::MAG_FILTER, osg::Texture2D::LINEAR);
	Line 52:     mTexture->setFilter(osg::Texture2D::MAG_FILTER, osg::Texture2D::LINEAR);
	Line 55:     mStateSet->setTextureAttributeAndModes(0, mTexture, osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);
	Line 55:     mStateSet->setTextureAttributeAndModes(0, mTexture, osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);
	Line 56:     mStateSet->addUniform(new osg::Uniform("smoke", 0));
	Line 59:     osg::ref_ptr<osg::Program> program = new osg::Program;
	Line 59:     osg::ref_ptr<osg::Program> program = new osg::Program;
	Line 59:     osg::ref_ptr<osg::Program> program = new osg::Program;
	Line 61:     program->addShader(ShaderMaster::getInstance().createShader(osg::Shader::VERTEX, "stackSmokeVert.glsl"));
	Line 62:     program->addShader(ShaderMaster::getInstance().createShader(osg::Shader::FRAGMENT, "stackSmokeFrag.glsl"));
	Line 64:     mStateSet->setAttributeAndModes(program.get(), osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);
	Line 64:     mStateSet->setAttributeAndModes(program.get(), osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);
	Line 66:     mStateSet->setRenderingHint(osg::StateSet::TRANSPARENT_BIN);
	Line 67:     osg::ref_ptr<osg::Depth> depth = new osg::Depth;
	Line 67:     osg::ref_ptr<osg::Depth> depth = new osg::Depth;
	Line 67:     osg::ref_ptr<osg::Depth> depth = new osg::Depth;
	Line 69:     mStateSet->setAttributeAndModes(depth, osg::StateAttribute::ON);
	Line 70:     mStateSet->setMode(GL_BLEND, osg::StateAttribute::ON);
	Line 71:     mStateSet->setMode(GL_SAMPLE_ALPHA_TO_COVERAGE, osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);
	Line 71:     mStateSet->setMode(GL_SAMPLE_ALPHA_TO_COVERAGE, osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);
	Line 73:     mWindDirUniform = new osg::Uniform("windDir", 0.f);
	Line 74:     mWindSpeedUniform = new osg::Uniform("windSpeed", 0.f);
	Line 75:     mTimeUniform = new osg::Uniform("time", 0.f);
	Line 88: void SmokeStacks::addStack(int vehicleId, osg::Vec3 stackPos, float scale)
	Line 90:     mStacksAdded[vehicleId].push_back(std::pair<osg::Vec3, float>(stackPos, scale));
	Line 94: void SmokeStacks::addToOSG(osg::Group* root)
	Line 102:     std::map<int, std::vector<std::pair<osg::Vec3, float> > >::iterator vIter = mStacksAdded.find(vehicleId);
	Line 153:             const std::vector<std::pair<osg::Vec3, float> >* stacks = &(add_iter->second);
  D:\Development\psim\src\subview\SmokeStacks.h (18 hits)
	Line 18: class SmokeStacks : public osg::Switch
	Line 25:     SmokeStacks(const SmokeStacks& stacks, const osg::CopyOp& copyop = osg::CopyOp::SHALLOW_COPY) :
	Line 25:     SmokeStacks(const SmokeStacks& stacks, const osg::CopyOp& copyop = osg::CopyOp::SHALLOW_COPY) :
	Line 26:     osg::Switch(stacks, copyop)
	Line 31:     void addStack(int vehicleId, osg::Vec3 stackPos, float scale);
	Line 32:     void addToOSG(osg::Group* root);
	Line 44:     std::map<int, std::vector<std::pair<osg::Vec3, float> > > mStacksAdded;
	Line 47:     typedef std::map<int, std::vector<std::pair<osg::Vec3, float> > >::const_iterator add_stack_iter;
	Line 49:     osg::ref_ptr<osg::Uniform> mWindDirUniform;
	Line 49:     osg::ref_ptr<osg::Uniform> mWindDirUniform;
	Line 50:     osg::ref_ptr<osg::Uniform> mWindSpeedUniform;
	Line 50:     osg::ref_ptr<osg::Uniform> mWindSpeedUniform;
	Line 51:     osg::ref_ptr<osg::Uniform> mTimeUniform;
	Line 51:     osg::ref_ptr<osg::Uniform> mTimeUniform;
	Line 53:     osg::ref_ptr<osg::Texture2D> mTexture;
	Line 53:     osg::ref_ptr<osg::Texture2D> mTexture;
	Line 54:     osg::ref_ptr<osg::StateSet> mStateSet;
	Line 54:     osg::ref_ptr<osg::StateSet> mStateSet;
  D:\Development\psim\src\subview\SmokeStacksUpdate.cpp (2 hits)
	Line 24: void SmokeStacksUpdate::operator()(osg::Node* node, osg::NodeVisitor* nv)
	Line 24: void SmokeStacksUpdate::operator()(osg::Node* node, osg::NodeVisitor* nv)
  D:\Development\psim\src\subview\SmokeStacksUpdate.h (3 hits)
	Line 15: class SmokeStacksUpdate : public osg::NodeCallback
	Line 23:     virtual void operator()(osg::Node* node, osg::NodeVisitor* nv);
	Line 23:     virtual void operator()(osg::Node* node, osg::NodeVisitor* nv);
  D:\Development\psim\src\subview\SmokeTrails.cpp (88 hits)
	Line 51: SmokeTrails::SmokeTrails(const SmokeTrails& trails, const osg::CopyOp& copyop/* = osg::CopyOp::SHALLOW_COPY*/) :
	Line 51: SmokeTrails::SmokeTrails(const SmokeTrails& trails, const osg::CopyOp& copyop/* = osg::CopyOp::SHALLOW_COPY*/) :
	Line 52: osg::Group(trails, copyop)
	Line 60: mState(new osg::State),
	Line 61: mDepthImage(new osg::Image)
	Line 71:     mStateSet = new osg::StateSet;
	Line 75:     osg::ref_ptr<osg::Image> img;
	Line 75:     osg::ref_ptr<osg::Image> img;
	Line 77:     mTexture = new osg::Texture2D;
	Line 79:     mTexture->setWrap(osg::Texture::WRAP_S, osg::Texture::CLAMP);
	Line 79:     mTexture->setWrap(osg::Texture::WRAP_S, osg::Texture::CLAMP);
	Line 80:     mTexture->setWrap(osg::Texture::WRAP_T, osg::Texture::CLAMP);
	Line 80:     mTexture->setWrap(osg::Texture::WRAP_T, osg::Texture::CLAMP);
	Line 81:     mTexture->setFilter(osg::Texture2D::MIN_FILTER, osg::Texture2D::LINEAR_MIPMAP_LINEAR);
	Line 81:     mTexture->setFilter(osg::Texture2D::MIN_FILTER, osg::Texture2D::LINEAR_MIPMAP_LINEAR);
	Line 82:     mTexture->setFilter(osg::Texture2D::MAG_FILTER, osg::Texture2D::LINEAR);
	Line 82:     mTexture->setFilter(osg::Texture2D::MAG_FILTER, osg::Texture2D::LINEAR);
	Line 85:     mStateSet->setTextureAttributeAndModes(0, mTexture, osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);
	Line 85:     mStateSet->setTextureAttributeAndModes(0, mTexture, osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);
	Line 86:     mStateSet->addUniform(new osg::Uniform("smoke", 0));
	Line 89:     mDepthTex = new osg::Texture2D;
	Line 92:     mDepthTex->setWrap(osg::Texture::WRAP_S, osg::Texture::CLAMP);
	Line 92:     mDepthTex->setWrap(osg::Texture::WRAP_S, osg::Texture::CLAMP);
	Line 93:     mDepthTex->setWrap(osg::Texture::WRAP_T, osg::Texture::CLAMP);
	Line 93:     mDepthTex->setWrap(osg::Texture::WRAP_T, osg::Texture::CLAMP);
	Line 94:     mDepthTex->setFilter(osg::Texture2D::MIN_FILTER, osg::Texture2D::LINEAR_MIPMAP_LINEAR);
	Line 94:     mDepthTex->setFilter(osg::Texture2D::MIN_FILTER, osg::Texture2D::LINEAR_MIPMAP_LINEAR);
	Line 95:     mDepthTex->setFilter(osg::Texture2D::MAG_FILTER, osg::Texture2D::LINEAR);
	Line 95:     mDepthTex->setFilter(osg::Texture2D::MAG_FILTER, osg::Texture2D::LINEAR);
	Line 96:     mStateSet->setTextureAttributeAndModes(1, mDepthTex, osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);
	Line 96:     mStateSet->setTextureAttributeAndModes(1, mDepthTex, osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);
	Line 97:     mStateSet->addUniform(new osg::Uniform("depth", 1));
	Line 100:     osg::ref_ptr<osg::Program> program = new osg::Program;
	Line 100:     osg::ref_ptr<osg::Program> program = new osg::Program;
	Line 100:     osg::ref_ptr<osg::Program> program = new osg::Program;
	Line 102:     program->addShader(ShaderMaster::getInstance().createShader(osg::Shader::VERTEX, "smokeTrailPuffVert.glsl"));
	Line 103:     program->addShader(ShaderMaster::getInstance().createShader(osg::Shader::FRAGMENT, "smokeTrailPuffFrag.glsl"));
	Line 106:     mStateSet->setAttributeAndModes(program.get(), osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);
	Line 106:     mStateSet->setAttributeAndModes(program.get(), osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);
	Line 108:     mStateSet->setRenderingHint(osg::StateSet::TRANSPARENT_BIN);
	Line 110:     osg::ref_ptr<osg::Depth> depth = new osg::Depth;
	Line 110:     osg::ref_ptr<osg::Depth> depth = new osg::Depth;
	Line 110:     osg::ref_ptr<osg::Depth> depth = new osg::Depth;
	Line 112:     mStateSet->setAttributeAndModes(depth, osg::StateAttribute::ON);
	Line 113:     mStateSet->setMode(GL_BLEND, osg::StateAttribute::ON);
	Line 114:     mStateSet->setMode(GL_CULL_FACE, osg::StateAttribute::PROTECTED | osg::StateAttribute::OFF);
	Line 114:     mStateSet->setMode(GL_CULL_FACE, osg::StateAttribute::PROTECTED | osg::StateAttribute::OFF);
	Line 115:     //mStateSet->setMode(GL_SAMPLE_ALPHA_TO_COVERAGE, osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);
	Line 115:     //mStateSet->setMode(GL_SAMPLE_ALPHA_TO_COVERAGE, osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);
	Line 118:     osg::ref_ptr<osg::BlendFunc> blend = new osg::BlendFunc;
	Line 118:     osg::ref_ptr<osg::BlendFunc> blend = new osg::BlendFunc;
	Line 118:     osg::ref_ptr<osg::BlendFunc> blend = new osg::BlendFunc;
	Line 119:     blend->setFunction(osg::BlendFunc::SRC_ALPHA, osg::BlendFunc::ONE_MINUS_SRC_ALPHA);
	Line 119:     blend->setFunction(osg::BlendFunc::SRC_ALPHA, osg::BlendFunc::ONE_MINUS_SRC_ALPHA);
	Line 120:     mStateSet->setAttributeAndModes(blend, osg::StateAttribute::ON);
	Line 121:     mViewMatInvUniform = new osg::Uniform("viewMatInv", osg::Matrixf::identity());
	Line 121:     mViewMatInvUniform = new osg::Uniform("viewMatInv", osg::Matrixf::identity());
	Line 122:     mWindDirUniform = new osg::Uniform("windDir", 0.f);
	Line 123:     mWindSpeedUniform = new osg::Uniform("windSpeed", 0.f);
	Line 124:     mTimeUniform = new osg::Uniform("time", 0.f);
	Line 125:     mLightCoeffUniform = new osg::Uniform("lightCoeff", 1.0f);
	Line 126:     mInvScreenWidthHeightUniform = new osg::Uniform("invScreenWidthHeight", osg::Vec2(1.f / SubviewConfig::winWidth, 1.f / SubviewConfig::winHeight));
	Line 126:     mInvScreenWidthHeightUniform = new osg::Uniform("invScreenWidthHeight", osg::Vec2(1.f / SubviewConfig::winWidth, 1.f / SubviewConfig::winHeight));
	Line 127:     mEyeAboveUniform = new osg::Uniform("eyeAbove", false);
	Line 163: void SmokeTrails::addToOSG(osg::Group* root)
	Line 231:                 osg::ref_ptr<SmokeTrailsPuff> puff = new SmokeTrailsPuff(mLastUpdateSeq, life_time_seq, current_time_offset, life_time, *info);
	Line 233:                 osg::ref_ptr<osg::Geode> geode = new osg::Geode();
	Line 233:                 osg::ref_ptr<osg::Geode> geode = new osg::Geode();
	Line 233:                 osg::ref_ptr<osg::Geode> geode = new osg::Geode();
	Line 237:                 osg::ref_ptr<osg::MatrixTransform> matrixXform = new osg::MatrixTransform();
	Line 237:                 osg::ref_ptr<osg::MatrixTransform> matrixXform = new osg::MatrixTransform();
	Line 237:                 osg::ref_ptr<osg::MatrixTransform> matrixXform = new osg::MatrixTransform();
	Line 239:                 osg::Matrixd mat_pos;
	Line 255:                             osg::Vec3f position = puff->getPosition();
	Line 259:                             osg::ref_ptr<osg::Geode> newgeode = new osg::Geode();
	Line 259:                             osg::ref_ptr<osg::Geode> newgeode = new osg::Geode();
	Line 259:                             osg::ref_ptr<osg::Geode> newgeode = new osg::Geode();
	Line 262:                             osg::ref_ptr<osg::MatrixTransform> offsetXform = new osg::MatrixTransform();
	Line 262:                             osg::ref_ptr<osg::MatrixTransform> offsetXform = new osg::MatrixTransform();
	Line 262:                             osg::ref_ptr<osg::MatrixTransform> offsetXform = new osg::MatrixTransform();
	Line 263:                             osg::Matrixd mat_pos;
	Line 283:             osg::Transform* xform = this->getChild(child)->asTransform();
	Line 289:             osg::MatrixTransform* matrixXform = xform->asMatrixTransform();
	Line 295:             osg::Geode* geode = xform->getChild(0)->asGeode();
	Line 316:                     osg::Matrixd mat_pos;
	Line 317:                     osg::Vec3f pos = puff->getPosition();
	Line 319:                     pos += osg::Vec3f(Shared->glEnv.windSpd * dt*cosdir, Shared->glEnv.windSpd * dt*sindir, 0.0);
	Line 338:     mInvScreenWidthHeightUniform->set(osg::Vec2(1.f / SubviewConfig::winWidth, 1.f / SubviewConfig::winHeight));
  D:\Development\psim\src\subview\SmokeTrails.h (28 hits)
	Line 20: class SmokeTrails : public osg::Group
	Line 26:     SmokeTrails(const SmokeTrails& trails, const osg::CopyOp& copyop = osg::CopyOp::SHALLOW_COPY);
	Line 26:     SmokeTrails(const SmokeTrails& trails, const osg::CopyOp& copyop = osg::CopyOp::SHALLOW_COPY);
	Line 30:     void addToOSG(osg::Group* root);
	Line 37:     osg::ref_ptr<osg::StateSet> mStateSet;
	Line 37:     osg::ref_ptr<osg::StateSet> mStateSet;
	Line 38:     osg::ref_ptr<osg::State> mState;
	Line 38:     osg::ref_ptr<osg::State> mState;
	Line 39:     osg::ref_ptr<osg::Image> mDepthImage;
	Line 39:     osg::ref_ptr<osg::Image> mDepthImage;
	Line 41:     osg::ref_ptr<osg::Texture2D> mTexture;
	Line 41:     osg::ref_ptr<osg::Texture2D> mTexture;
	Line 42:     osg::ref_ptr<osg::Uniform> mViewMatInvUniform;
	Line 42:     osg::ref_ptr<osg::Uniform> mViewMatInvUniform;
	Line 43:     osg::ref_ptr<osg::Uniform> mWindDirUniform;
	Line 43:     osg::ref_ptr<osg::Uniform> mWindDirUniform;
	Line 44:     osg::ref_ptr<osg::Uniform> mWindSpeedUniform;
	Line 44:     osg::ref_ptr<osg::Uniform> mWindSpeedUniform;
	Line 45:     osg::ref_ptr<osg::Uniform> mTimeUniform;
	Line 45:     osg::ref_ptr<osg::Uniform> mTimeUniform;
	Line 46:     osg::ref_ptr<osg::Uniform> mLightCoeffUniform;
	Line 46:     osg::ref_ptr<osg::Uniform> mLightCoeffUniform;
	Line 47:     osg::ref_ptr<osg::Uniform> mInvScreenWidthHeightUniform;
	Line 47:     osg::ref_ptr<osg::Uniform> mInvScreenWidthHeightUniform;
	Line 48:     osg::ref_ptr<osg::Texture2D> mDepthTex;
	Line 48:     osg::ref_ptr<osg::Texture2D> mDepthTex;
	Line 49:     osg::ref_ptr<osg::Uniform> mEyeAboveUniform;
	Line 49:     osg::ref_ptr<osg::Uniform> mEyeAboveUniform;
  D:\Development\psim\src\subview\SmokeTrailsPuff.cpp (31 hits)
	Line 26: SmokeTrailsPuff::SmokeTrailsPuff(const SmokeTrailsPuff& puff, const osg::CopyOp& copyop/* = osg::CopyOp::SHALLOW_COPY*/) :
	Line 26: SmokeTrailsPuff::SmokeTrailsPuff(const SmokeTrailsPuff& puff, const osg::CopyOp& copyop/* = osg::CopyOp::SHALLOW_COPY*/) :
	Line 27: osg::Geometry(puff, copyop)
	Line 59:     std::vector< osg::Vec4f > vertices;
	Line 60:     std::vector< osg::Vec4f > tex_coords;
	Line 61:     std::vector< osg::Vec4f > bb_coords;
	Line 71:         vertices.push_back(osg::Vec4f(0.0, 0.0, 0.0, birthSeq));
	Line 75:         tex_coords.push_back(osg::Vec4f(uu, vv, startTime, lifeTime));
	Line 76:         bb_coords.push_back(osg::Vec4f(local_verts[ii][0], local_verts[ii][1], 0.0, info.mSmokeScale));
	Line 81:     osg::ref_ptr<osg::Vec4Array> vertices_array = new osg::Vec4Array(vertices.size(), (osg::Vec4f*) &(vertices.front()));
	Line 81:     osg::ref_ptr<osg::Vec4Array> vertices_array = new osg::Vec4Array(vertices.size(), (osg::Vec4f*) &(vertices.front()));
	Line 81:     osg::ref_ptr<osg::Vec4Array> vertices_array = new osg::Vec4Array(vertices.size(), (osg::Vec4f*) &(vertices.front()));
	Line 81:     osg::ref_ptr<osg::Vec4Array> vertices_array = new osg::Vec4Array(vertices.size(), (osg::Vec4f*) &(vertices.front()));
	Line 84:     osg::ref_ptr<osg::Vec4Array> tex_coords_array = new osg::Vec4Array(tex_coords.size(), (osg::Vec4f*)&(tex_coords.front()));
	Line 84:     osg::ref_ptr<osg::Vec4Array> tex_coords_array = new osg::Vec4Array(tex_coords.size(), (osg::Vec4f*)&(tex_coords.front()));
	Line 84:     osg::ref_ptr<osg::Vec4Array> tex_coords_array = new osg::Vec4Array(tex_coords.size(), (osg::Vec4f*)&(tex_coords.front()));
	Line 84:     osg::ref_ptr<osg::Vec4Array> tex_coords_array = new osg::Vec4Array(tex_coords.size(), (osg::Vec4f*)&(tex_coords.front()));
	Line 87:     osg::ref_ptr<osg::Vec4Array> bb_coords_array = new osg::Vec4Array(bb_coords.size(), (osg::Vec4f*)&(bb_coords.front()));
	Line 87:     osg::ref_ptr<osg::Vec4Array> bb_coords_array = new osg::Vec4Array(bb_coords.size(), (osg::Vec4f*)&(bb_coords.front()));
	Line 87:     osg::ref_ptr<osg::Vec4Array> bb_coords_array = new osg::Vec4Array(bb_coords.size(), (osg::Vec4f*)&(bb_coords.front()));
	Line 87:     osg::ref_ptr<osg::Vec4Array> bb_coords_array = new osg::Vec4Array(bb_coords.size(), (osg::Vec4f*)&(bb_coords.front()));
	Line 90:     osg::Geometry::PrimitiveSetList prim_list;
	Line 91:     osg::ref_ptr<osg::DrawElementsUInt> de_quads = new osg::DrawElementsUInt(osg::PrimitiveSet::QUADS, indices.size(),
	Line 91:     osg::ref_ptr<osg::DrawElementsUInt> de_quads = new osg::DrawElementsUInt(osg::PrimitiveSet::QUADS, indices.size(),
	Line 91:     osg::ref_ptr<osg::DrawElementsUInt> de_quads = new osg::DrawElementsUInt(osg::PrimitiveSet::QUADS, indices.size(),
	Line 91:     osg::ref_ptr<osg::DrawElementsUInt> de_quads = new osg::DrawElementsUInt(osg::PrimitiveSet::QUADS, indices.size(),
	Line 101: osg::BoundingBox SmokeTrailsPuff::computeBound() const
	Line 106:     osg::BoundingBox bbox(-nominal, -nominal, -nominal, nominal, nominal, nominal);
	Line 121: osg::Vec3f SmokeTrailsPuff::getPosition() const
	Line 125:     osg::Vec3f position;
	Line 132: void SmokeTrailsPuff::setPosition(osg::Vec3f newPosition)
  D:\Development\psim\src\subview\SmokeTrailsPuff.h (7 hits)
	Line 18: class SmokeTrailsPuff : public osg::Geometry
	Line 24:     SmokeTrailsPuff(const SmokeTrailsPuff& puff, const osg::CopyOp& copyop = osg::CopyOp::SHALLOW_COPY);
	Line 24:     SmokeTrailsPuff(const SmokeTrailsPuff& puff, const osg::CopyOp& copyop = osg::CopyOp::SHALLOW_COPY);
	Line 28:     virtual osg::BoundingBox computeBound() const;
	Line 31:     osg::Vec3f getPosition() const;
	Line 32:     void setPosition(osg::Vec3f);
	Line 45:     osg::Vec3f mSmokeOffset;
  D:\Development\psim\src\subview\SmokeTrailsUpdate.cpp (2 hits)
	Line 24: void SmokeTrailsUpdate::operator()(osg::Node* node, osg::NodeVisitor* nv)
	Line 24: void SmokeTrailsUpdate::operator()(osg::Node* node, osg::NodeVisitor* nv)
  D:\Development\psim\src\subview\SmokeTrailsUpdate.h (3 hits)
	Line 16: class SmokeTrailsUpdate : public osg::NodeCallback
	Line 24:     virtual void operator()(osg::Node* node, osg::NodeVisitor* nv);
	Line 24:     virtual void operator()(osg::Node* node, osg::NodeVisitor* nv);
  D:\Development\psim\src\subview\Snapshot.cpp (5 hits)
	Line 132: void Snapshot::takeSnapshot(osg::Image* targetImage, unsigned int xorg, unsigned int yorg, unsigned int width, unsigned int height)
	Line 142:     osg::ref_ptr<osg::Image> image;
	Line 142:     osg::ref_ptr<osg::Image> image;
	Line 143:     image = new osg::Image;
	Line 151: void Snapshot::takeSnapshot(const osg::Camera& camera, SnapshotType snapshotType)
  D:\Development\psim\src\subview\Snapshot.h (2 hits)
	Line 16:     static void takeSnapshot(osg::Image* targetImage, unsigned int xorg, unsigned int yorg, unsigned int width, unsigned int height);
	Line 17:     static void takeSnapshot(const osg::Camera &camera, SnapshotType snapshotType);
  D:\Development\psim\src\subview\SoundingAlertDB.cpp (5 hits)
	Line 20: SoundingAlertDB::SoundingAlertDB(Vehicle* vehicle, osg::Geode *node) :
	Line 21: TextBox(node, "msttcore/consola.ttf", osg::Vec4(0.f, 0.f, 0.f, 1.f)),
	Line 22: //TextBox(node, "gnu-free/FreeMonoBold.ttf", osg::Vec4(0.f, 0.f, 0.f, 1.f) ),
	Line 27: void SoundingAlertDB::operator()(osg::Node * node, osg::NodeVisitor * nv)
	Line 27: void SoundingAlertDB::operator()(osg::Node * node, osg::NodeVisitor * nv)
  D:\Development\psim\src\subview\SoundingAlertDB.h (3 hits)
	Line 21:     SoundingAlertDB(Vehicle* vehicle, osg::Geode *node);
	Line 23:     virtual void operator()(osg::Node * node, osg::NodeVisitor * nv);
	Line 23:     virtual void operator()(osg::Node * node, osg::NodeVisitor * nv);
  D:\Development\psim\src\subview\SoundingDB.cpp (5 hits)
	Line 24: SoundingDB::SoundingDB(Vehicle* vehicle, osg::Geode *node) :
	Line 25: TextBox(node, "msttcore/consola.ttf", osg::Vec4(0.f, 0.f, 0.f, 1.f)),
	Line 26: //TextBox(node, "gnu-free/FreeMonoBold.ttf", osg::Vec4(0.f, 0.f, 0.f, 1.f) ),
	Line 31: void SoundingDB::operator()(osg::Node * node, osg::NodeVisitor * nv)
	Line 31: void SoundingDB::operator()(osg::Node * node, osg::NodeVisitor * nv)
  D:\Development\psim\src\subview\SoundingDB.h (3 hits)
	Line 21:     SoundingDB(Vehicle* vehicle, osg::Geode *node);
	Line 23:     virtual void operator()(osg::Node * node, osg::NodeVisitor * nv);
	Line 23:     virtual void operator()(osg::Node * node, osg::NodeVisitor * nv);
  D:\Development\psim\src\subview\SpeedDB.cpp (5 hits)
	Line 21: SpeedDB::SpeedDB(Vehicle* vehicle, osg::Geode *node) :
	Line 22: TextBox(node, "msttcore/consola.ttf", osg::Vec4(0.f, 0.f, 0.f, 1.f)),
	Line 23: //TextBox(node, "gnu-free/FreeMonoBold.ttf", osg::Vec4(0.f, 0.f, 0.f, 1.f) ),
	Line 28: void SpeedDB::operator()(osg::Node * node, osg::NodeVisitor * nv)
	Line 28: void SpeedDB::operator()(osg::Node * node, osg::NodeVisitor * nv)
  D:\Development\psim\src\subview\SpeedDB.h (3 hits)
	Line 21:     SpeedDB(Vehicle* vehicle, osg::Geode *node);
	Line 23:     virtual void operator()(osg::Node * node, osg::NodeVisitor * nv);
	Line 23:     virtual void operator()(osg::Node * node, osg::NodeVisitor * nv);
  D:\Development\psim\src\subview\StackSmoke.cpp (8 hits)
	Line 25: StackSmoke::StackSmoke(int vehicleId, const std::vector<std::pair<osg::Vec3, float> >* stacks) :
	Line 31:     osg::ref_ptr<osg::Geode> geode = new osg::Geode();
	Line 31:     osg::ref_ptr<osg::Geode> geode = new osg::Geode();
	Line 31:     osg::ref_ptr<osg::Geode> geode = new osg::Geode();
	Line 40:     mHeadingUniform = new osg::Uniform("heading", 0.f);
	Line 41:     mSpeedUniform = new osg::Uniform("speed", 0.f);
	Line 68:     osg::Matrixd mat_pos;
	Line 75:         osg::Vec3f contactLoc = vehicle->getContactLoc();
  D:\Development\psim\src\subview\StackSmoke.h (12 hits)
	Line 23: class StackSmoke : public osg::MatrixTransform
	Line 26:     StackSmoke(int vehicleId, const std::vector<std::pair<osg::Vec3, float> >* stacks);
	Line 33:     StackSmoke(const StackSmoke& fire, const osg::CopyOp& copyop = osg::CopyOp::SHALLOW_COPY) :
	Line 33:     StackSmoke(const StackSmoke& fire, const osg::CopyOp& copyop = osg::CopyOp::SHALLOW_COPY) :
	Line 34:     osg::MatrixTransform(fire, copyop)
	Line 46:     osg::ref_ptr<StackSmokeGeometry> mGeometry;
	Line 48:     osg::ref_ptr<osg::StateSet> mStateSet;
	Line 48:     osg::ref_ptr<osg::StateSet> mStateSet;
	Line 50:     osg::ref_ptr<osg::Uniform> mHeadingUniform;
	Line 50:     osg::ref_ptr<osg::Uniform> mHeadingUniform;
	Line 51:     osg::ref_ptr<osg::Uniform> mSpeedUniform;
	Line 51:     osg::ref_ptr<osg::Uniform> mSpeedUniform;
  D:\Development\psim\src\subview\StackSmokeGeometry.cpp (27 hits)
	Line 27: StackSmokeGeometry::StackSmokeGeometry(int vehicleId, const std::vector<std::pair<osg::Vec3, float> >* stacks)
	Line 45:     std::vector< osg::Vec4f > vertices;
	Line 46:     std::vector< osg::Vec4f > tex_coords;
	Line 47:     std::vector< osg::Vec4f > bb_coords;
	Line 64:                 osg::Vec3f xyz = (*stacks)[ii].first;
	Line 65:                 vertices.push_back(osg::Vec4f(xyz, height_frac)); // (float)vehicle_id));
	Line 69:                 tex_coords.push_back(osg::Vec4f(uu, vv, dx, dy));
	Line 70:                 bb_coords.push_back(osg::Vec4f(local_verts[jj][0], local_verts[jj][1],
	Line 79:     osg::ref_ptr<osg::Vec4Array> vertices_array = new osg::Vec4Array(vertices.size(), (osg::Vec4f*) &(vertices.front()));
	Line 79:     osg::ref_ptr<osg::Vec4Array> vertices_array = new osg::Vec4Array(vertices.size(), (osg::Vec4f*) &(vertices.front()));
	Line 79:     osg::ref_ptr<osg::Vec4Array> vertices_array = new osg::Vec4Array(vertices.size(), (osg::Vec4f*) &(vertices.front()));
	Line 79:     osg::ref_ptr<osg::Vec4Array> vertices_array = new osg::Vec4Array(vertices.size(), (osg::Vec4f*) &(vertices.front()));
	Line 82:     osg::ref_ptr<osg::Vec4Array> tex_coords_array = new osg::Vec4Array(tex_coords.size(), (osg::Vec4f*)&(tex_coords.front()));
	Line 82:     osg::ref_ptr<osg::Vec4Array> tex_coords_array = new osg::Vec4Array(tex_coords.size(), (osg::Vec4f*)&(tex_coords.front()));
	Line 82:     osg::ref_ptr<osg::Vec4Array> tex_coords_array = new osg::Vec4Array(tex_coords.size(), (osg::Vec4f*)&(tex_coords.front()));
	Line 82:     osg::ref_ptr<osg::Vec4Array> tex_coords_array = new osg::Vec4Array(tex_coords.size(), (osg::Vec4f*)&(tex_coords.front()));
	Line 85:     osg::ref_ptr<osg::Vec4Array> bb_coords_array = new osg::Vec4Array(bb_coords.size(), (osg::Vec4f*)&(bb_coords.front()));
	Line 85:     osg::ref_ptr<osg::Vec4Array> bb_coords_array = new osg::Vec4Array(bb_coords.size(), (osg::Vec4f*)&(bb_coords.front()));
	Line 85:     osg::ref_ptr<osg::Vec4Array> bb_coords_array = new osg::Vec4Array(bb_coords.size(), (osg::Vec4f*)&(bb_coords.front()));
	Line 85:     osg::ref_ptr<osg::Vec4Array> bb_coords_array = new osg::Vec4Array(bb_coords.size(), (osg::Vec4f*)&(bb_coords.front()));
	Line 88:     osg::Geometry::PrimitiveSetList prim_list;
	Line 89:     osg::ref_ptr<osg::DrawElementsUInt> de_quads = new osg::DrawElementsUInt(osg::PrimitiveSet::QUADS, indices.size(),
	Line 89:     osg::ref_ptr<osg::DrawElementsUInt> de_quads = new osg::DrawElementsUInt(osg::PrimitiveSet::QUADS, indices.size(),
	Line 89:     osg::ref_ptr<osg::DrawElementsUInt> de_quads = new osg::DrawElementsUInt(osg::PrimitiveSet::QUADS, indices.size(),
	Line 89:     osg::ref_ptr<osg::DrawElementsUInt> de_quads = new osg::DrawElementsUInt(osg::PrimitiveSet::QUADS, indices.size(),
	Line 99: osg::BoundingBox StackSmokeGeometry::computeBound() const
	Line 103:     osg::BoundingBox bbox(-nominal, -nominal, -nominal, nominal, nominal, nominal);
  D:\Development\psim\src\subview\StackSmokeGeometry.h (7 hits)
	Line 21: class StackSmokeGeometry : public osg::Geometry
	Line 24:     StackSmokeGeometry(int vehicleId, const std::vector<std::pair<osg::Vec3, float> >* stacks);
	Line 27:     StackSmokeGeometry(const StackSmokeGeometry& smoke, const osg::CopyOp& copyop = osg::CopyOp::SHALLOW_COPY) :
	Line 27:     StackSmokeGeometry(const StackSmokeGeometry& smoke, const osg::CopyOp& copyop = osg::CopyOp::SHALLOW_COPY) :
	Line 28:     osg::Geometry(smoke, copyop)
	Line 37:     virtual osg::BoundingBox computeBound() const;
	Line 46:     std::vector<std::pair<osg::Vec3, float> > mStacks;
  D:\Development\psim\src\subview\Stadimeter.cpp (42 hits)
	Line 31: Stadimeter::Stadimeter(const Stadimeter& Stadimeter, const osg::CopyOp& copyop/* = osg::CopyOp::SHALLOW_COPY*/) :
	Line 31: Stadimeter::Stadimeter(const Stadimeter& Stadimeter, const osg::CopyOp& copyop/* = osg::CopyOp::SHALLOW_COPY*/) :
	Line 32: osg::Geometry(Stadimeter, copyop)
	Line 40: Stadimeter::Stadimeter(osg::Group *root)
	Line 42:     sProjectionMatrix = new osg::RefMatrix(osg::Matrix::ortho(-10.0, 10.0, -10.0, 10.0, -1.0, 1.0));
	Line 42:     sProjectionMatrix = new osg::RefMatrix(osg::Matrix::ortho(-10.0, 10.0, -10.0, 10.0, -1.0, 1.0));
	Line 43:     sModelviewMatrix = new osg::RefMatrix(osg::Matrixf::identity());
	Line 43:     sModelviewMatrix = new osg::RefMatrix(osg::Matrixf::identity());
	Line 47:     textureRect = new osg::TextureRectangle;
	Line 50:     textureRect->setFilter(osg::TextureRectangle::MIN_FILTER, osg::TextureRectangle::LINEAR);
	Line 50:     textureRect->setFilter(osg::TextureRectangle::MIN_FILTER, osg::TextureRectangle::LINEAR);
	Line 51:     textureRect->setFilter(osg::TextureRectangle::MAG_FILTER, osg::TextureRectangle::LINEAR);
	Line 51:     textureRect->setFilter(osg::TextureRectangle::MAG_FILTER, osg::TextureRectangle::LINEAR);
	Line 53:     stateSet = new osg::StateSet;
	Line 54:     stateSet->setTextureAttributeAndModes(0, textureRect, osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);
	Line 54:     stateSet->setTextureAttributeAndModes(0, textureRect, osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);
	Line 57:     stateSet->setRenderingHint(osg::StateSet::TRANSPARENT_BIN);
	Line 60:     osg::Geode* geode = new osg::Geode();
	Line 60:     osg::Geode* geode = new osg::Geode();
	Line 63:     quadSwitch = new osg::Switch;
	Line 69:     stateSet->setMode(GL_LIGHTING, osg::StateAttribute::OFF);
	Line 70:     stateSet->setMode(GL_DEPTH_TEST, osg::StateAttribute::OFF);
	Line 71:     stateSet->setMode(GL_BLEND, osg::StateAttribute::ON);
	Line 73:     stateSet->setTextureAttributeAndModes(0, textureRect, osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);
	Line 73:     stateSet->setTextureAttributeAndModes(0, textureRect, osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);
	Line 74:     stateSet->addUniform(new osg::Uniform("texture", 0));
	Line 75:     stadiAdjustUniform = new osg::Uniform("stadiAdjust", 0.f);
	Line 90:     osg::ref_ptr<osg::Shader> fshader = new osg::Shader(osg::Shader::FRAGMENT, shaderSource);
	Line 90:     osg::ref_ptr<osg::Shader> fshader = new osg::Shader(osg::Shader::FRAGMENT, shaderSource);
	Line 90:     osg::ref_ptr<osg::Shader> fshader = new osg::Shader(osg::Shader::FRAGMENT, shaderSource);
	Line 90:     osg::ref_ptr<osg::Shader> fshader = new osg::Shader(osg::Shader::FRAGMENT, shaderSource);
	Line 91:     osg::ref_ptr<osg::Program> program = new osg::Program;
	Line 91:     osg::ref_ptr<osg::Program> program = new osg::Program;
	Line 91:     osg::ref_ptr<osg::Program> program = new osg::Program;
	Line 93:     stateSet->setAttributeAndModes(program.get(), osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);
	Line 93:     stateSet->setAttributeAndModes(program.get(), osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);
	Line 102: void Stadimeter::drawImplementation(osg::RenderInfo& ri) const
	Line 108:     osg::Texture::TextureObject* textureObject = textureRect->getTextureObject(0);
	Line 181: osg::BoundingBox Stadimeter::computeBound() const
	Line 183:     osg::BoundingBox bbox;
	Line 184:     bbox.expandBy(osg::Vec3(-10000.f, -10000.f, -10000.f));
	Line 185:     bbox.expandBy(osg::Vec3(10000.f, 10000.f, 10000.f));
  D:\Development\psim\src\subview\Stadimeter.h (17 hits)
	Line 18: class Stadimeter : public osg::Geometry
	Line 25:     osg::ref_ptr<osg::RefMatrix> sProjectionMatrix;
	Line 25:     osg::ref_ptr<osg::RefMatrix> sProjectionMatrix;
	Line 26:     osg::ref_ptr<osg::RefMatrix> sModelviewMatrix;
	Line 26:     osg::ref_ptr<osg::RefMatrix> sModelviewMatrix;
	Line 27:     osg::ref_ptr<osg::StateSet> stateSet;
	Line 27:     osg::ref_ptr<osg::StateSet> stateSet;
	Line 29:     osg::TextureRectangle *textureRect;
	Line 30:     osg::ref_ptr<osg::Switch> quadSwitch;
	Line 30:     osg::ref_ptr<osg::Switch> quadSwitch;
	Line 31:     osg::ref_ptr<osg::Uniform> stadiAdjustUniform;
	Line 31:     osg::ref_ptr<osg::Uniform> stadiAdjustUniform;
	Line 36:     Stadimeter(const Stadimeter& Stadimeter, const osg::CopyOp& copyop = osg::CopyOp::SHALLOW_COPY);
	Line 36:     Stadimeter(const Stadimeter& Stadimeter, const osg::CopyOp& copyop = osg::CopyOp::SHALLOW_COPY);
	Line 39:     Stadimeter(osg::Group *root);
	Line 40:     virtual void drawImplementation(osg::RenderInfo& ri) const;
	Line 41:     virtual osg::BoundingBox computeBound() const;
  D:\Development\psim\src\subview\Starfield.cpp (46 hits)
	Line 38:     osg::ref_ptr<osg::Vec3Array> vertices = new osg::Vec3Array;
	Line 38:     osg::ref_ptr<osg::Vec3Array> vertices = new osg::Vec3Array;
	Line 38:     osg::ref_ptr<osg::Vec3Array> vertices = new osg::Vec3Array;
	Line 39:     osg::ref_ptr<osg::Vec4Array> colors = new osg::Vec4Array;
	Line 39:     osg::ref_ptr<osg::Vec4Array> colors = new osg::Vec4Array;
	Line 39:     osg::ref_ptr<osg::Vec4Array> colors = new osg::Vec4Array;
	Line 43:     osg::ref_ptr<osg::Geometry> geometry = new osg::Geometry;
	Line 43:     osg::ref_ptr<osg::Geometry> geometry = new osg::Geometry;
	Line 43:     osg::ref_ptr<osg::Geometry> geometry = new osg::Geometry;
	Line 46:     geometry->addPrimitiveSet(new osg::DrawArrays(osg::PrimitiveSet::POINTS, 0, vertices->size()));
	Line 46:     geometry->addPrimitiveSet(new osg::DrawArrays(osg::PrimitiveSet::POINTS, 0, vertices->size()));
	Line 48:     geometry->setColorBinding(osg::Geometry::BIND_PER_VERTEX);
	Line 51:     osg::ref_ptr<osg::StateSet> stateset = new osg::StateSet;
	Line 51:     osg::ref_ptr<osg::StateSet> stateset = new osg::StateSet;
	Line 51:     osg::ref_ptr<osg::StateSet> stateset = new osg::StateSet;
	Line 52:     stateset->setMode(GL_BLEND, osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);
	Line 52:     stateset->setMode(GL_BLEND, osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);
	Line 53:     stateset->setMode(GL_LIGHTING, osg::StateAttribute::OFF | osg::StateAttribute::OVERRIDE);
	Line 53:     stateset->setMode(GL_LIGHTING, osg::StateAttribute::OFF | osg::StateAttribute::OVERRIDE);
	Line 55:     stateset->setMode(GL_DEPTH_TEST, osg::StateAttribute::OFF);
	Line 56:     osg::ref_ptr<osg::Point> point = new osg::Point(pointSize);
	Line 56:     osg::ref_ptr<osg::Point> point = new osg::Point(pointSize);
	Line 56:     osg::ref_ptr<osg::Point> point = new osg::Point(pointSize);
	Line 61:     osg::ref_ptr<osg::Program> program = new osg::Program;
	Line 61:     osg::ref_ptr<osg::Program> program = new osg::Program;
	Line 61:     osg::ref_ptr<osg::Program> program = new osg::Program;
	Line 62:     program->addShader(ShaderMaster::getInstance().createShader(osg::Shader::FRAGMENT, "starFrag.glsl"));
	Line 63:     stateset->setAttributeAndModes(program.get(), osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);
	Line 63:     stateset->setAttributeAndModes(program.get(), osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);
	Line 66:     osg::ref_ptr<osg::Geode> geode = new osg::Geode();
	Line 66:     osg::ref_ptr<osg::Geode> geode = new osg::Geode();
	Line 66:     osg::ref_ptr<osg::Geode> geode = new osg::Geode();
	Line 71:     mTransformPtr = new osg::MatrixTransform;
	Line 74:     mTransformPtr->setMatrix(osg::Matrix::scale(STARS_SCALE, STARS_SCALE, STARS_SCALE));
	Line 81: osg::Group* Starfield::GetNode()
	Line 92:             osg::Matrix::rotate(osg::inDegrees(dailyRotation), 0.0f, 0.0f, 1.0f) *
	Line 92:             osg::Matrix::rotate(osg::inDegrees(dailyRotation), 0.0f, 0.0f, 1.0f) *
	Line 93:             osg::Matrix::rotate(osg::inDegrees(STARS_HEADING_OFFSET - lon), 0.0f, 0.0f, 1.0f) *
	Line 93:             osg::Matrix::rotate(osg::inDegrees(STARS_HEADING_OFFSET - lon), 0.0f, 0.0f, 1.0f) *
	Line 94:             osg::Matrix::rotate(osg::inDegrees(STARS_PITCH_OFFSET + lat), 1.0f, 0.0f, 0.0f) *
	Line 94:             osg::Matrix::rotate(osg::inDegrees(STARS_PITCH_OFFSET + lat), 1.0f, 0.0f, 0.0f) *
	Line 95:             osg::Matrix::scale(STARS_SCALE, STARS_SCALE, STARS_SCALE));
	Line 98: void Starfield::ReadStarFile(osg::Vec3Array *verticesPtr, osg::Vec4Array *colorsPtr)
	Line 98: void Starfield::ReadStarFile(osg::Vec3Array *verticesPtr, osg::Vec4Array *colorsPtr)
	Line 121:             verticesPtr->push_back(osg::Vec3(xPos, yPos, zPos));
	Line 122:             colorsPtr->push_back(osg::Vec4(intensity, intensity, intensity, std::min(2.0f*intensity, 1.0f)));
  D:\Development\psim\src\subview\Starfield.h (5 hits)
	Line 18:         osg::Group* GetNode();
	Line 23:         void ReadStarFile(osg::Vec3Array *verticesPtr, osg::Vec4Array *colorsPtr);
	Line 23:         void ReadStarFile(osg::Vec3Array *verticesPtr, osg::Vec4Array *colorsPtr);
	Line 25:         osg::ref_ptr<osg::MatrixTransform> mTransformPtr;
	Line 25:         osg::ref_ptr<osg::MatrixTransform> mTransformPtr;
  D:\Development\psim\src\subview\StateSetUpdater.cpp (12 hits)
	Line 16: StateSetUpdater::StateSetUpdater(const StateSetUpdater &copy, const osg::CopyOp &copyop)
	Line 17: : osg::NodeCallback(copy, copyop)
	Line 21: void StateSetUpdater::operator()(osg::Node* node, osg::NodeVisitor* nv)
	Line 21: void StateSetUpdater::operator()(osg::Node* node, osg::NodeVisitor* nv)
	Line 26:         osg::StateSet* src = node->getOrCreateStateSet();
	Line 30:             mStateSets[i] = static_cast<osg::StateSet*> (osg::clone(src, osg::CopyOp::SHALLOW_COPY));
	Line 30:             mStateSets[i] = static_cast<osg::StateSet*> (osg::clone(src, osg::CopyOp::SHALLOW_COPY));
	Line 30:             mStateSets[i] = static_cast<osg::StateSet*> (osg::clone(src, osg::CopyOp::SHALLOW_COPY));
	Line 34:             mStateSets[i]->setDataVariance(osg::Object::DYNAMIC);
	Line 55: void StateSetUpdater::apply(osg::StateSet* stateset, osg::NodeVisitor* nv)
	Line 55: void StateSetUpdater::apply(osg::StateSet* stateset, osg::NodeVisitor* nv)
	Line 59: void StateSetUpdater::setDefaults(osg::StateSet* stateset)
  D:\Development\psim\src\subview\StateSetUpdater.h (9 hits)
	Line 10: class StateSetUpdater : public osg::NodeCallback
	Line 14:     StateSetUpdater(const StateSetUpdater& copy, const osg::CopyOp& copyop);
	Line 16:     virtual void operator()(osg::Node* node, osg::NodeVisitor* nv);
	Line 16:     virtual void operator()(osg::Node* node, osg::NodeVisitor* nv);
	Line 18:     virtual void apply(osg::StateSet* stateset, osg::NodeVisitor* nv);
	Line 18:     virtual void apply(osg::StateSet* stateset, osg::NodeVisitor* nv);
	Line 20:     virtual void setDefaults(osg::StateSet* stateset);
	Line 26:     osg::ref_ptr<osg::StateSet> mStateSets[2];
	Line 26:     osg::ref_ptr<osg::StateSet> mStateSets[2];
  D:\Development\psim\src\subview\SternLightCallback.cpp (9 hits)
	Line 19: SternLightCallback::SternLightCallback(Vehicle *vehicle, osg::Vec3f position) :
	Line 26: void SternLightCallback::operator()(osg::Node *node, osg::NodeVisitor *nv)
	Line 26: void SternLightCallback::operator()(osg::Node *node, osg::NodeVisitor *nv)
	Line 28:     osg::Geode* sternLightGeode = dynamic_cast<osg::Geode*> (node); // dynamic cast will return null if node isn't a geode
	Line 28:     osg::Geode* sternLightGeode = dynamic_cast<osg::Geode*> (node); // dynamic cast will return null if node isn't a geode
	Line 34:             osg::Vec3 localDir(-1., 0., 0.);
	Line 35:             mVehicle->setSternLightPos(osg::computeLocalToWorld(nv->getNodePath()).preMult(mLocalPos));
	Line 36:             mVehicle->setSternLightDir(osg::Matrix::rotate(osg::DegreesToRadians(mVehicle->getHeading()), 0.f, 0.f, 1.f).preMult(localDir));
	Line 36:             mVehicle->setSternLightDir(osg::Matrix::rotate(osg::DegreesToRadians(mVehicle->getHeading()), 0.f, 0.f, 1.f).preMult(localDir));
  D:\Development\psim\src\subview\SternLightCallback.h (5 hits)
	Line 17: class SternLightCallback : public osg::NodeCallback
	Line 20:     SternLightCallback(Vehicle *vehicle, osg::Vec3f position);
	Line 21:     virtual void operator()(osg::Node *node, osg::NodeVisitor *nv);
	Line 21:     virtual void operator()(osg::Node *node, osg::NodeVisitor *nv);
	Line 25:     osg::Vec3f mLocalPos;
  D:\Development\psim\src\subview\Sub.cpp (1 hit)
	Line 55:         Shared->scopePivotOffset = osg::Vec3(0.f, 0.f, 0.f);
  D:\Development\psim\src\subview\SubHud.cpp (2 hits)
	Line 30: void SubHud::drawImplementation(osg::RenderInfo& ri) const
	Line 36: void SubHud::draw(osg::RenderInfo& ri)
  D:\Development\psim\src\subview\SubHud.h (2 hits)
	Line 14:     virtual void drawImplementation(osg::RenderInfo& ri) const;
	Line 17:     void draw(osg::RenderInfo& ri);
  D:\Development\psim\src\subview\SubTelemeter.cpp (16 hits)
	Line 156: void SubTelemeter::drawImplementation(osg::RenderInfo& ri) const
	Line 248:     stateSet = new osg::StateSet;
	Line 250:     stateSet->setTextureAttributeAndModes(0, NULL, osg::StateAttribute::OFF | osg::StateAttribute::OVERRIDE);
	Line 250:     stateSet->setTextureAttributeAndModes(0, NULL, osg::StateAttribute::OFF | osg::StateAttribute::OVERRIDE);
	Line 253:     osg::ref_ptr<osg::Program> program = new osg::Program;
	Line 253:     osg::ref_ptr<osg::Program> program = new osg::Program;
	Line 253:     osg::ref_ptr<osg::Program> program = new osg::Program;
	Line 255:     textureEnabledUniform = new osg::Uniform("textureEnabled", 0.0f);
	Line 256:     redUniform = new osg::Uniform("red", 0.0f);
	Line 257:     greenUniform = new osg::Uniform("green", 0.0f);
	Line 258:     blueUniform = new osg::Uniform("blue", 0.0f);
	Line 259:     alphaUniform = new osg::Uniform("alpha", 1.0f);
	Line 267:     program->addShader(ShaderMaster::getInstance().createShader(osg::Shader::FRAGMENT, "overlayFrag.glsl"));
	Line 273:     stateSet->setAttributeAndModes(program.get(), osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);
	Line 273:     stateSet->setAttributeAndModes(program.get(), osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);
	Line 276:     stateSet->setMode(GL_DEPTH_TEST, osg::StateAttribute::OFF);
  D:\Development\psim\src\subview\SubTelemeter.h (1 hit)
	Line 25:     virtual void drawImplementation(osg::RenderInfo& ri) const;
  D:\Development\psim\src\subview\subview.cpp (5 hits)
	Line 66: extern osg::ref_ptr<osg::Camera> mainCamera;
	Line 66: extern osg::ref_ptr<osg::Camera> mainCamera;
	Line 318:     Shared->overlayBoarder = osg::Vec2();
	Line 339:     SubviewConfig::orientationOffset = osg::Vec3(0.0, 0.0, 0.0);
	Line 340:     SubviewConfig::viewOffset = osg::Vec3(0.0, 0.0, 0.0);
  D:\Development\psim\src\subview\SubviewConfig.cpp (4 hits)
	Line 33: osg::Vec3 SubviewConfig::orientationOffset = osg::Vec3(0.0, 0.0, 0.0);
	Line 33: osg::Vec3 SubviewConfig::orientationOffset = osg::Vec3(0.0, 0.0, 0.0);
	Line 34: osg::Vec3 SubviewConfig::viewOffset = osg::Vec3(0.0, 0.0, 0.0);
	Line 34: osg::Vec3 SubviewConfig::viewOffset = osg::Vec3(0.0, 0.0, 0.0);
  D:\Development\psim\src\subview\SubviewConfig.h (4 hits)
	Line 39:     static osg::Vec3 orientationOffset; // = osg::Vec3(0.0, 0.0, 0.0);
	Line 39:     static osg::Vec3 orientationOffset; // = osg::Vec3(0.0, 0.0, 0.0);
	Line 40:     static osg::Vec3 viewOffset; // = osg::Vec3(0.0, 0.0, 0.0);
	Line 40:     static osg::Vec3 viewOffset; // = osg::Vec3(0.0, 0.0, 0.0);
  D:\Development\psim\src\subview\SubviewSwapCallback.cpp (16 hits)
	Line 30: extern osg::ref_ptr<PsimCameraManipulator> cameraManipulator;
	Line 39: osg::GraphicsContext::SwapCallback(),
	Line 50: void SubviewSwapCallback::enableSecondaryWrite(std::string key, int width, int height, osg::Image* image, osg::Texture* tex)
	Line 50: void SubviewSwapCallback::enableSecondaryWrite(std::string key, int width, int height, osg::Image* image, osg::Texture* tex)
	Line 63: void SubviewSwapCallback::swapBuffersImplementation(osg::GraphicsContext *gc)
	Line 137:                 osg::Quat ScalableQuat(osg::inDegrees(Frustum.ViewAngleC + 90.0), osg::Vec3(-1., -0., 0.),
	Line 137:                 osg::Quat ScalableQuat(osg::inDegrees(Frustum.ViewAngleC + 90.0), osg::Vec3(-1., -0., 0.),
	Line 137:                 osg::Quat ScalableQuat(osg::inDegrees(Frustum.ViewAngleC + 90.0), osg::Vec3(-1., -0., 0.),
	Line 138:                         osg::inDegrees(Frustum.ViewAngleB), osg::Vec3(0., 0., 1.),
	Line 138:                         osg::inDegrees(Frustum.ViewAngleB), osg::Vec3(0., 0., 1.),
	Line 139:                         osg::inDegrees(Frustum.ViewAngleA), osg::Vec3(0., 1., 0.));
	Line 139:                         osg::inDegrees(Frustum.ViewAngleA), osg::Vec3(0., 1., 0.));
	Line 143:                 _cameraManipulator->setFrustum(osg::RadiansToDegrees(res[0]), osg::RadiansToDegrees(res[1]), osg::RadiansToDegrees(res[2]),
	Line 143:                 _cameraManipulator->setFrustum(osg::RadiansToDegrees(res[0]), osg::RadiansToDegrees(res[1]), osg::RadiansToDegrees(res[2]),
	Line 143:                 _cameraManipulator->setFrustum(osg::RadiansToDegrees(res[0]), osg::RadiansToDegrees(res[1]), osg::RadiansToDegrees(res[2]),
	Line 185: void SubviewSwapCallback::quatToEuler(const osg::Quat& q, double res[], RotSeq rotSeq)
  D:\Development\psim\src\subview\SubviewSwapCallback.h (5 hits)
	Line 19: class SubviewSwapCallback : public osg::GraphicsContext::SwapCallback
	Line 27:     void enableSecondaryWrite(std::string key, int width, int height, osg::Image* image, osg::Texture* tex);
	Line 27:     void enableSecondaryWrite(std::string key, int width, int height, osg::Image* image, osg::Texture* tex);
	Line 30:     virtual void swapBuffersImplementation(osg::GraphicsContext* gc);
	Line 55:     void quatToEuler(const osg::Quat& q, double res[], RotSeq rotSeq);
  D:\Development\psim\src\subview\SubviewUtils.cpp (98 hits)
	Line 154: osg::Vec3f SubviewUtils::GetOceanColor(VisualEffectEnum visualEffect)
	Line 156:     osg::Vec3f color;
	Line 180: void SubviewUtils::SetVisualEffectState(osg::StateSet *stateSet, VisualEffectEnum& visualEffect)
	Line 182:     addDynamicUniform(stateSet, "irMode", osg::Uniform::BOOL, (visualEffect == VISUAL_IR || visualEffect == VISUAL_IR_NOISE),
	Line 188:     addDynamicUniform(stateSet, "lightEnhancement", osg::Uniform::BOOL, visualEffect == VISUAL_NVG || visualEffect == VISUAL_LLL,
	Line 194:     addDynamicUniform(stateSet, "baseOceanColor", osg::Uniform::FLOAT_VEC3, SubviewUtils::GetOceanColor(visualEffect),
	Line 200:     addDynamicUniform(stateSet, "fogColor", osg::Uniform::FLOAT_VEC4, CalcFogColor(visualEffect),
	Line 206:     addDynamicUniform(stateSet, "fogDelta", osg::Uniform::FLOAT, GetVisibilityRange(Shared->glEnv.visRange, Shared->eyeAbove, Shared->hud.scopeElev, visualEffect),
	Line 212:     addDynamicUniform(stateSet, "cloudFog", osg::Uniform::FLOAT, GetCloudFog(Shared->glEnv.precipType, Shared->glEnv.visRange, Shared->eyeAbove, Shared->hud.scopeElev, visualEffect),
	Line 219: osg::Vec4f SubviewUtils::CalcFogColor(VisualEffectEnum visualEffect)
	Line 221:     osg::Vec4f fogColor;
	Line 226:     osg::Vec4 baseColor;
	Line 235:         baseColor = osg::Vec4f(0.9f, 0.9f, 0.9f, 1.0f) * density;
	Line 236:         baseColor += osg::Vec4(sun_moon->GetBottomColor(), 1.0) * (1.0f - density);
	Line 362: osg::Vec4 SubviewUtils::ColorToGrayscale(osg::Vec4 color)
	Line 362: osg::Vec4 SubviewUtils::ColorToGrayscale(osg::Vec4 color)
	Line 366:     osg::Vec4 gray(grayscale, grayscale, grayscale, color[3]);
	Line 414: void SubviewUtils::AddQuad(osg::ref_ptr<osg::Vec3Array> vertices, osg::ref_ptr<osg::Vec2Array> texcoords, double xOffset, double zOffset)
	Line 414: void SubviewUtils::AddQuad(osg::ref_ptr<osg::Vec3Array> vertices, osg::ref_ptr<osg::Vec2Array> texcoords, double xOffset, double zOffset)
	Line 414: void SubviewUtils::AddQuad(osg::ref_ptr<osg::Vec3Array> vertices, osg::ref_ptr<osg::Vec2Array> texcoords, double xOffset, double zOffset)
	Line 414: void SubviewUtils::AddQuad(osg::ref_ptr<osg::Vec3Array> vertices, osg::ref_ptr<osg::Vec2Array> texcoords, double xOffset, double zOffset)
	Line 416:     vertices->push_back(osg::Vec3d(-1.0 + xOffset, 0.0, -1.0 + zOffset));
	Line 417:     texcoords->push_back(osg::Vec2(0.0, 0.0));
	Line 419:     vertices->push_back(osg::Vec3d(1.0 + xOffset, 0.0, -1.0 + zOffset));
	Line 420:     texcoords->push_back(osg::Vec2(1.0, 0.0));
	Line 422:     vertices->push_back(osg::Vec3d(1.0 + xOffset, 0.0, 1.0 + zOffset));
	Line 423:     texcoords->push_back(osg::Vec2(1.0, 1.0));
	Line 425:     vertices->push_back(osg::Vec3d(-1.0 + xOffset, 0.0, 1.0 + zOffset));
	Line 426:     texcoords->push_back(osg::Vec2(0.0, 1.0));
	Line 434: osg::Vec3 SubviewUtils::GetCelestialPosition(float azimuth, float elevation)
	Line 453:     return osg::Vec3(-X * xyscale, Y * xyscale, Z);
	Line 548: std::string& SubviewUtils::PrintVec3(std::string & str, const osg::Vec3 &v)
	Line 572: std::string& SubviewUtils::PrintQuat(std::string & str, const osg::Quat &v)
	Line 1276: osg::ref_ptr<osg::Texture2D> SubviewUtils::CreateTexture(const std::string &path, bool wrapS, bool wrapT, bool wrapR)
	Line 1276: osg::ref_ptr<osg::Texture2D> SubviewUtils::CreateTexture(const std::string &path, bool wrapS, bool wrapT, bool wrapR)
	Line 1282: osg::ref_ptr<osg::Texture2D> SubviewUtils::CreateTexture(char *path, bool wrapS, bool wrapT, bool wrapR)
	Line 1282: osg::ref_ptr<osg::Texture2D> SubviewUtils::CreateTexture(char *path, bool wrapS, bool wrapT, bool wrapR)
	Line 1284:     osg::ref_ptr<osg::Image> image;
	Line 1284:     osg::ref_ptr<osg::Image> image;
	Line 1291:     osg::ref_ptr<osg::Texture2D> texture = new osg::Texture2D;
	Line 1291:     osg::ref_ptr<osg::Texture2D> texture = new osg::Texture2D;
	Line 1291:     osg::ref_ptr<osg::Texture2D> texture = new osg::Texture2D;
	Line 1293:     texture.get()->setFilter(osg::Texture2D::MIN_FILTER, osg::Texture2D::LINEAR_MIPMAP_NEAREST);
	Line 1293:     texture.get()->setFilter(osg::Texture2D::MIN_FILTER, osg::Texture2D::LINEAR_MIPMAP_NEAREST);
	Line 1294:     texture.get()->setFilter(osg::Texture2D::MAG_FILTER, osg::Texture2D::LINEAR);
	Line 1294:     texture.get()->setFilter(osg::Texture2D::MAG_FILTER, osg::Texture2D::LINEAR);
	Line 1295:     texture.get()->setWrap(osg::Texture2D::WRAP_S, wrapS ? osg::Texture2D::REPEAT : osg::Texture2D::CLAMP);
	Line 1295:     texture.get()->setWrap(osg::Texture2D::WRAP_S, wrapS ? osg::Texture2D::REPEAT : osg::Texture2D::CLAMP);
	Line 1295:     texture.get()->setWrap(osg::Texture2D::WRAP_S, wrapS ? osg::Texture2D::REPEAT : osg::Texture2D::CLAMP);
	Line 1296:     texture.get()->setWrap(osg::Texture2D::WRAP_T, wrapT ? osg::Texture2D::REPEAT : osg::Texture2D::CLAMP);
	Line 1296:     texture.get()->setWrap(osg::Texture2D::WRAP_T, wrapT ? osg::Texture2D::REPEAT : osg::Texture2D::CLAMP);
	Line 1296:     texture.get()->setWrap(osg::Texture2D::WRAP_T, wrapT ? osg::Texture2D::REPEAT : osg::Texture2D::CLAMP);
	Line 1297:     texture.get()->setWrap(osg::Texture2D::WRAP_R, wrapR ? osg::Texture2D::REPEAT : osg::Texture2D::CLAMP);
	Line 1297:     texture.get()->setWrap(osg::Texture2D::WRAP_R, wrapR ? osg::Texture2D::REPEAT : osg::Texture2D::CLAMP);
	Line 1297:     texture.get()->setWrap(osg::Texture2D::WRAP_R, wrapR ? osg::Texture2D::REPEAT : osg::Texture2D::CLAMP);
	Line 1330: void SubviewUtils::PaintString(osg::ref_ptr<osg::Geode> geode, std::string number)
	Line 1330: void SubviewUtils::PaintString(osg::ref_ptr<osg::Geode> geode, std::string number)
	Line 1341:     osg::ref_ptr<osg::Geometry> baseDrawable = (osg::Geometry*)(geode->getDrawable(0));
	Line 1341:     osg::ref_ptr<osg::Geometry> baseDrawable = (osg::Geometry*)(geode->getDrawable(0));
	Line 1341:     osg::ref_ptr<osg::Geometry> baseDrawable = (osg::Geometry*)(geode->getDrawable(0));
	Line 1344:     osg::ref_ptr<osg::Vec3Array> coords = (osg::Vec3Array*)(baseDrawable->getVertexArray());
	Line 1344:     osg::ref_ptr<osg::Vec3Array> coords = (osg::Vec3Array*)(baseDrawable->getVertexArray());
	Line 1344:     osg::ref_ptr<osg::Vec3Array> coords = (osg::Vec3Array*)(baseDrawable->getVertexArray());
	Line 1347:     osg::ref_ptr<osg::StateSet> stateSet = baseDrawable->getStateSet();
	Line 1347:     osg::ref_ptr<osg::StateSet> stateSet = baseDrawable->getStateSet();
	Line 1353:     osg::Vec3 lowerLeft;
	Line 1354:     osg::Vec3 upperLeft;
	Line 1355:     osg::Vec3 upperRight;
	Line 1356:     osg::Vec3 lowerRight;
	Line 1357:     osg::ref_ptr<osg::Vec3Array> newCoords;
	Line 1357:     osg::ref_ptr<osg::Vec3Array> newCoords;
	Line 1358:     osg::ref_ptr<osg::Vec2Array> texcoords;
	Line 1358:     osg::ref_ptr<osg::Vec2Array> texcoords;
	Line 1359:     osg::ref_ptr<osg::Vec3Array> normals;
	Line 1359:     osg::ref_ptr<osg::Vec3Array> normals;
	Line 1361:     newCoords = new osg::Vec3Array;
	Line 1362:     texcoords = new osg::Vec2Array;
	Line 1363:     normals = new osg::Vec3Array;
	Line 1373:         osg::Vec3 stride = (upperLeft - upperRight) / float(numChars);
	Line 1376:         osg::Vec3 normal = (upperLeft - upperRight)^(lowerLeft - upperRight);
	Line 1389:         osg::Vec4 ret;
	Line 1401:             texcoords->push_back(osg::Vec2(ret[2], ret[3]));
	Line 1402:             texcoords->push_back(osg::Vec2(ret[0], ret[3]));
	Line 1403:             texcoords->push_back(osg::Vec2(ret[0], ret[1]));
	Line 1404:             texcoords->push_back(osg::Vec2(ret[2], ret[1]));
	Line 1415:     osg::ref_ptr<osg::DrawArrays> primitive = new osg::DrawArrays(osg::PrimitiveSet::QUADS, 0, newCoords->size());
	Line 1415:     osg::ref_ptr<osg::DrawArrays> primitive = new osg::DrawArrays(osg::PrimitiveSet::QUADS, 0, newCoords->size());
	Line 1415:     osg::ref_ptr<osg::DrawArrays> primitive = new osg::DrawArrays(osg::PrimitiveSet::QUADS, 0, newCoords->size());
	Line 1415:     osg::ref_ptr<osg::DrawArrays> primitive = new osg::DrawArrays(osg::PrimitiveSet::QUADS, 0, newCoords->size());
	Line 1418:     osg::ref_ptr<osg::Geometry> newFace = new osg::Geometry();
	Line 1418:     osg::ref_ptr<osg::Geometry> newFace = new osg::Geometry();
	Line 1418:     osg::ref_ptr<osg::Geometry> newFace = new osg::Geometry();
	Line 1422:     newFace->setNormalBinding(osg::Geometry::BIND_PER_VERTEX);
	Line 1432: osg::Vec4 SubviewUtils::GetShipLettersTexCoords(char letter)
	Line 1437:     osg::Vec4 ret;
	Line 1441:         ret = osg::Vec4((51.2 * (asciival - 48)) / width,
	Line 1449:         ret = osg::Vec4((float(letter % 10) * 51.2) / width,
	Line 1458:         ret = osg::Vec4(0.0, 0.0, 0.0, 0.0);
  D:\Development\psim\src\subview\SubviewUtils.h (19 hits)
	Line 35:     static osg::Vec4f CalcFogColor(VisualEffectEnum visualEffect);
	Line 38:     static osg::ref_ptr<osg::Texture2D> CreateTexture(char *path, bool wrapS = false, bool wrapT = false, bool wrapR = false);
	Line 38:     static osg::ref_ptr<osg::Texture2D> CreateTexture(char *path, bool wrapS = false, bool wrapT = false, bool wrapR = false);
	Line 39:     static osg::ref_ptr<osg::Texture2D> CreateTexture(const std::string &path, bool wrapS = false, bool wrapT = false, bool wrapR = false);
	Line 39:     static osg::ref_ptr<osg::Texture2D> CreateTexture(const std::string &path, bool wrapS = false, bool wrapT = false, bool wrapR = false);
	Line 47:     static osg::Vec3f GetOceanColor(VisualEffectEnum visualEffect);
	Line 51:     static void AddQuad(osg::ref_ptr<osg::Vec3Array> vertices, osg::ref_ptr<osg::Vec2Array> texcoords, double xOffset, double zOffset);
	Line 51:     static void AddQuad(osg::ref_ptr<osg::Vec3Array> vertices, osg::ref_ptr<osg::Vec2Array> texcoords, double xOffset, double zOffset);
	Line 51:     static void AddQuad(osg::ref_ptr<osg::Vec3Array> vertices, osg::ref_ptr<osg::Vec2Array> texcoords, double xOffset, double zOffset);
	Line 51:     static void AddQuad(osg::ref_ptr<osg::Vec3Array> vertices, osg::ref_ptr<osg::Vec2Array> texcoords, double xOffset, double zOffset);
	Line 53:     static osg::Vec3 GetCelestialPosition(float azimuth, float elevation);
	Line 60:     static void PaintString(osg::ref_ptr<osg::Geode> geode, std::string number);
	Line 60:     static void PaintString(osg::ref_ptr<osg::Geode> geode, std::string number);
	Line 63:     static std::string & PrintQuat(std::string & str, const osg::Quat &v);
	Line 66:     static std::string & PrintVec3(std::string & str, const osg::Vec3 &v);
	Line 79:     static void SetVisualEffectState(osg::StateSet *stateSet, VisualEffectEnum& visualEffect);
	Line 94:     static osg::Vec4 ColorToGrayscale(osg::Vec4 color);
	Line 94:     static osg::Vec4 ColorToGrayscale(osg::Vec4 color);
	Line 95:     static osg::Vec4 GetShipLettersTexCoords(char letter);
  D:\Development\psim\src\subview\SubviewViewer.cpp (32 hits)
	Line 27: extern osg::ref_ptr<osg::Camera> mainCamera;
	Line 27: extern osg::ref_ptr<osg::Camera> mainCamera;
	Line 28: extern osg::ref_ptr<osg::Camera> nearCamera;
	Line 28: extern osg::ref_ptr<osg::Camera> nearCamera;
	Line 29: extern osg::ref_ptr<osg::Camera> secondaryCamera; // secondary rendering camera for dual views
	Line 29: extern osg::ref_ptr<osg::Camera> secondaryCamera; // secondary rendering camera for dual views
	Line 30: extern osg::ref_ptr<osg::Camera> projCamera; // renders stern wakes to a texture for projection onto the ocean's surface
	Line 30: extern osg::ref_ptr<osg::Camera> projCamera; // renders stern wakes to a texture for projection onto the ocean's surface
	Line 31: extern osg::ref_ptr<osg::Camera> reflCamera; // renders stern wakes to a texture for projection onto the ocean's surface
	Line 31: extern osg::ref_ptr<osg::Camera> reflCamera; // renders stern wakes to a texture for projection onto the ocean's surface
	Line 35: osg::ref_ptr<osg::Uniform> SubviewViewer::atmoCUniform = NULL;
	Line 35: osg::ref_ptr<osg::Uniform> SubviewViewer::atmoCUniform = NULL;
	Line 37: SubviewViewer::SubviewViewer(osg::ArgumentParser& arguments)
	Line 47:     mLastFrameTime = osg::Timer::instance()->tick();
	Line 71:         osg::Timer_t current_time = osg::Timer::instance()->tick();
	Line 71:         osg::Timer_t current_time = osg::Timer::instance()->tick();
	Line 72:         if (osg::Timer::instance()->delta_s(mLastFrameTime, current_time) < mMinFrameTime) return;
	Line 91:     // osg::notify(osg::NOTICE)<<std::endl<<"CompositeViewer::frame()"<<std::endl<<std::endl;
	Line 91:     // osg::notify(osg::NOTICE)<<std::endl<<"CompositeViewer::frame()"<<std::endl<<std::endl;
	Line 110:     osg::Matrixd reflMat;
	Line 111:     reflMat.makeScale(osg::Vec3d(1.0, 1.0, -1.0));
	Line 115:     osg::Uniform * uniform = reflCamera->getOrCreateStateSet()->getOrCreateUniform("osg_ViewMatrixInverse", osg::Uniform::FLOAT_MAT4);
	Line 115:     osg::Uniform * uniform = reflCamera->getOrCreateStateSet()->getOrCreateUniform("osg_ViewMatrixInverse", osg::Uniform::FLOAT_MAT4);
	Line 116:     uniform->set(osg::Matrix::inverse(reflMat * mainCamera->getViewMatrix())); //osg view matrix inverse.
	Line 117:     uniform = reflCamera->getOrCreateStateSet()->getOrCreateUniform("osg_ViewMatrix", osg::Uniform::FLOAT_MAT4);
	Line 133:         osg::Timer_t endFrameTime = osg::Timer::instance()->tick();
	Line 133:         osg::Timer_t endFrameTime = osg::Timer::instance()->tick();
	Line 134:         double elapsedTime = osg::Timer::instance()->delta_s(mLastFrameTime, endFrameTime);
	Line 142:         //        endFrameTime = osg::Timer::instance()->tick();
	Line 143:         //        elapsedTime = osg::Timer::instance()->delta_s(mLastFrameTime, endFrameTime);
	Line 169:         osg::Vec3f eye, center, dir, up;
	Line 176:             atmoCUniform->set(osg::Vec3f(center[2] + Rg, center[1], center[0]));
  D:\Development\psim\src\subview\SubviewViewer.h (4 hits)
	Line 22:     SubviewViewer(osg::ArgumentParser& arguments);
	Line 28:     static osg::ref_ptr<osg::Uniform> atmoCUniform;
	Line 28:     static osg::ref_ptr<osg::Uniform> atmoCUniform;
	Line 36:     osg::Timer_t mLastFrameTime;
  D:\Development\psim\src\subview\Sun.cpp (46 hits)
	Line 55:     osg::ref_ptr<osg::Vec3Array> vertices = new osg::Vec3Array;
	Line 55:     osg::ref_ptr<osg::Vec3Array> vertices = new osg::Vec3Array;
	Line 55:     osg::ref_ptr<osg::Vec3Array> vertices = new osg::Vec3Array;
	Line 56:     osg::ref_ptr<osg::Vec2Array> texcoords = new osg::Vec2Array;
	Line 56:     osg::ref_ptr<osg::Vec2Array> texcoords = new osg::Vec2Array;
	Line 56:     osg::ref_ptr<osg::Vec2Array> texcoords = new osg::Vec2Array;
	Line 60:     osg::ref_ptr<osg::Geometry> geometry = new osg::Geometry;
	Line 60:     osg::ref_ptr<osg::Geometry> geometry = new osg::Geometry;
	Line 60:     osg::ref_ptr<osg::Geometry> geometry = new osg::Geometry;
	Line 64:     geometry->addPrimitiveSet(new osg::DrawArrays(osg::PrimitiveSet::QUADS, 0, vertices->size()));
	Line 64:     geometry->addPrimitiveSet(new osg::DrawArrays(osg::PrimitiveSet::QUADS, 0, vertices->size()));
	Line 66:     osg::ref_ptr<osg::Program> program = new osg::Program;
	Line 66:     osg::ref_ptr<osg::Program> program = new osg::Program;
	Line 66:     osg::ref_ptr<osg::Program> program = new osg::Program;
	Line 67:     program->addShader(ShaderMaster::getInstance().createShader(osg::Shader::VERTEX, "sunVert.glsl"));
	Line 68:     program->addShader(ShaderMaster::getInstance().createShader(osg::Shader::FRAGMENT, "sunFrag.glsl"));
	Line 70:     osg::ref_ptr<osg::StateSet> stateset = new osg::StateSet;
	Line 70:     osg::ref_ptr<osg::StateSet> stateset = new osg::StateSet;
	Line 70:     osg::ref_ptr<osg::StateSet> stateset = new osg::StateSet;
	Line 72:     osg::Depth* depth = new osg::Depth;
	Line 72:     osg::Depth* depth = new osg::Depth;
	Line 74:     stateset->setAttributeAndModes(depth, osg::StateAttribute::ON);
	Line 75:     stateset->setMode(GL_BLEND, osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);
	Line 75:     stateset->setMode(GL_BLEND, osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);
	Line 79:     osg::ref_ptr<osg::Geode> geode = new osg::Geode();
	Line 79:     osg::ref_ptr<osg::Geode> geode = new osg::Geode();
	Line 79:     osg::ref_ptr<osg::Geode> geode = new osg::Geode();
	Line 83:     mTransformPtr = new osg::MatrixTransform;
	Line 87:     mGroupPtr = new osg::Group;
	Line 92:     rgb_bot = osg::Vec3(0.7f, 0.7f, 0.9f);
	Line 99: osg::Group* Sun::GetNode()
	Line 119: osg::Vec3 Sun::GetOldSunPosVec()
	Line 139: osg::Vec3 Sun::GetPos()
	Line 144: osg::Vec3 Sun::GetColor()
	Line 154: osg::Vec3 Sun::GetBottomColor()
	Line 261: void Sun::Update(double dayNumber, double latitude, double longitude, float moonIntensity, osg::Camera *camera)
	Line 340:     rgb_bot = osg::Vec3(r, g, b);
	Line 344:     mColor = osg::Vec3(Sr, Sg, Sb);
	Line 413: void Sun::Draw(double UT, osg::Camera *camera, Moon *moonPtr)
	Line 423:             osg::Matrix::rotate(osg::inDegrees(mElevation), 1.0f, 0.0f, 0.0f) *
	Line 423:             osg::Matrix::rotate(osg::inDegrees(mElevation), 1.0f, 0.0f, 0.0f) *
	Line 424:             osg::Matrix::rotate(osg::inDegrees(mAzimuth), 0.0f, 0.0f, 1.0f) *
	Line 424:             osg::Matrix::rotate(osg::inDegrees(mAzimuth), 0.0f, 0.0f, 1.0f) *
	Line 425:             osg::Matrix::scale(SUN_QUAD_SCALE, SUN_QUAD_SCALE, SUN_QUAD_SCALE) *
	Line 426:             osg::Matrix::translate(mPosition*SUN_DISTANCE));
	Line 436: osg::Vec3 Sun::getOldSunPos(double dayNumber, double latitude, double longitude, double minBack)
  D:\Development\psim\src\subview\Sun.h (16 hits)
	Line 30:         osg::Vec3 GetBottomColor();
	Line 31:         osg::Vec3 GetColor();
	Line 36:         osg::Group* GetNode();
	Line 37:         osg::Vec3 GetOldSunPosVec();
	Line 38:         osg::Vec3 GetPos();
	Line 44:         void Update(double dayNumber, double latitude, double longitude, float moonIntensity, osg::Camera *camera);
	Line 45:         void Draw(double UT, osg::Camera *camera, Moon *moonPtr);
	Line 70:         osg::Vec3 getOldSunPos(double dayNumber, double latitude, double longitude, double minBack);
	Line 76:         osg::Vec3 rgb_bot;
	Line 77:         osg::Vec3 oldSunPos;
	Line 84:         osg::Vec3 mColor;
	Line 87:         osg::Vec3 mPosition;
	Line 92:         osg::ref_ptr<osg::Group> mGroupPtr;
	Line 92:         osg::ref_ptr<osg::Group> mGroupPtr;
	Line 93:         osg::ref_ptr<osg::MatrixTransform> mTransformPtr;
	Line 93:         osg::ref_ptr<osg::MatrixTransform> mTransformPtr;
  D:\Development\psim\src\subview\SunFlare.cpp (64 hits)
	Line 108:     mFlareColorUniform = new osg::Uniform("flareColor", osg::Vec4(1.0, 0.5, 0.5, 1.0));
	Line 108:     mFlareColorUniform = new osg::Uniform("flareColor", osg::Vec4(1.0, 0.5, 0.5, 1.0));
	Line 109:     mFlareScaleUniform = new osg::Uniform("flareScale", 0.0f);
	Line 112:     osg::ref_ptr<osg::Program> program = new osg::Program;
	Line 112:     osg::ref_ptr<osg::Program> program = new osg::Program;
	Line 112:     osg::ref_ptr<osg::Program> program = new osg::Program;
	Line 113:     program->addShader(ShaderMaster::getInstance().createShader(osg::Shader::VERTEX, "flareVert.glsl"));
	Line 114:     program->addShader(ShaderMaster::getInstance().createShader(osg::Shader::FRAGMENT, "flareFrag.glsl"));
	Line 117:     osg::ref_ptr<osg::Geode> flareGeode = new osg::Geode();
	Line 117:     osg::ref_ptr<osg::Geode> flareGeode = new osg::Geode();
	Line 117:     osg::ref_ptr<osg::Geode> flareGeode = new osg::Geode();
	Line 161:     osg::ref_ptr<osg::StateSet> stateset = flareGeode->getOrCreateStateSet();
	Line 161:     osg::ref_ptr<osg::StateSet> stateset = flareGeode->getOrCreateStateSet();
	Line 164:     stateset->addUniform(new osg::Uniform("flareOriginX", FLARE_PRIMARY_X));
	Line 165:     stateset->addUniform(new osg::Uniform("texture", 0));
	Line 166:     stateset->setAttributeAndModes(program.get(), osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);
	Line 166:     stateset->setAttributeAndModes(program.get(), osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);
	Line 169:     mTransform = new osg::MatrixTransform;
	Line 178: osg::Group* SunFlare::GetNode()
	Line 183: void SunFlare::Update(osg::Vec3 sunColor, float sunElevation, int numOccludedPixels)
	Line 204:     mFlareColorUniform->set(osg::Vec4(sunColor, mFlareAlpha));
	Line 207: void SunFlare::Draw(float sunElevation, float sunAzimuth, osg::Vec3 sunPos, osg::Camera *camera)
	Line 207: void SunFlare::Draw(float sunElevation, float sunAzimuth, osg::Vec3 sunPos, osg::Camera *camera)
	Line 210:     osg::Vec3 flarePos = sunPos;
	Line 225:             osg::Matrix::rotate(flareRotate, 0.0f, 1.0f, 0.0) *
	Line 226:             osg::Matrix::rotate(osg::inDegrees(sunElevation), 1.0f, 0.0f, 0.0f) *
	Line 226:             osg::Matrix::rotate(osg::inDegrees(sunElevation), 1.0f, 0.0f, 0.0f) *
	Line 227:             osg::Matrix::rotate(osg::inDegrees(sunAzimuth), 0.0f, 0.0f, 1.0f) *
	Line 227:             osg::Matrix::rotate(osg::inDegrees(sunAzimuth), 0.0f, 0.0f, 1.0f) *
	Line 228:             osg::Matrix::scale(FLARE_SCALE, FLARE_SCALE, FLARE_SCALE) *
	Line 229:             osg::Matrix::translate(flarePos[0], flarePos[1], flarePos[2]));
	Line 241: void SunFlare::CalculateFlareTransform(osg::Vec3 flarePos, float& flareRotation, float& flareLength, osg::Camera *camera)
	Line 241: void SunFlare::CalculateFlareTransform(osg::Vec3 flarePos, float& flareRotation, float& flareLength, osg::Camera *camera)
	Line 243:     osg::Vec4 flareCoords = osg::Vec4(flarePos[0], flarePos[1], flarePos[2], 1.0);
	Line 243:     osg::Vec4 flareCoords = osg::Vec4(flarePos[0], flarePos[1], flarePos[2], 1.0);
	Line 245:     osg::Matrix viewMatrix = camera->getViewMatrix();
	Line 246:     osg::Matrix projectionMatrix = camera->getProjectionMatrix();
	Line 247:     osg::Matrix windowMatrix = camera->getViewport()->computeWindowMatrix();
	Line 275: osg::ref_ptr<osg::Geometry> SunFlare::CreateFlareGeometry(
	Line 275: osg::ref_ptr<osg::Geometry> SunFlare::CreateFlareGeometry(
	Line 279:     osg::ref_ptr<osg::Geometry> geometry = new osg::Geometry;
	Line 279:     osg::ref_ptr<osg::Geometry> geometry = new osg::Geometry;
	Line 279:     osg::ref_ptr<osg::Geometry> geometry = new osg::Geometry;
	Line 282:     osg::ref_ptr<osg::Vec3Array> vertices = new osg::Vec3Array;
	Line 282:     osg::ref_ptr<osg::Vec3Array> vertices = new osg::Vec3Array;
	Line 282:     osg::ref_ptr<osg::Vec3Array> vertices = new osg::Vec3Array;
	Line 283:     osg::ref_ptr<osg::Vec2Array> texcoords = new osg::Vec2Array;
	Line 283:     osg::ref_ptr<osg::Vec2Array> texcoords = new osg::Vec2Array;
	Line 283:     osg::ref_ptr<osg::Vec2Array> texcoords = new osg::Vec2Array;
	Line 289:     geometry->addPrimitiveSet(new osg::DrawArrays(osg::PrimitiveSet::QUADS, 0, vertices->size()));
	Line 289:     geometry->addPrimitiveSet(new osg::DrawArrays(osg::PrimitiveSet::QUADS, 0, vertices->size()));
	Line 295:     osg::BoundingBox bbox;
	Line 296:     bbox.expandBy(osg::Vec3(10000.f, 10000.f, 10000.f));
	Line 299:     osg::ref_ptr<osg::StateSet> stateset = new osg::StateSet;
	Line 299:     osg::ref_ptr<osg::StateSet> stateset = new osg::StateSet;
	Line 299:     osg::ref_ptr<osg::StateSet> stateset = new osg::StateSet;
	Line 305:     stateset->setMode(GL_DEPTH_TEST, osg::StateAttribute::OFF);
	Line 309:     stateset->setMode(GL_BLEND, osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);
	Line 309:     stateset->setMode(GL_BLEND, osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);
	Line 312:     stateset->addUniform(new osg::Uniform("artifactX", xOffset));
	Line 313:     stateset->addUniform(new osg::Uniform("artifactZ", zOffset));
	Line 314:     stateset->addUniform(new osg::Uniform("baseAlpha", baseAlpha));
	Line 315:     stateset->addUniform(new osg::Uniform("artifactScale", artifactScale));
	Line 316:     stateset->addUniform(new osg::Uniform("isWhiteOut", isWhiteOut));
  D:\Development\psim\src\subview\SunFlare.h (14 hits)
	Line 87:         osg::Group* GetNode();
	Line 89:         void Update(osg::Vec3 sunColor, float sunElevation, int numOccludedPixels);
	Line 90:         void Draw(float sunElevation, float sunAzimuth, osg::Vec3 sunPos, osg::Camera *camera);
	Line 90:         void Draw(float sunElevation, float sunAzimuth, osg::Vec3 sunPos, osg::Camera *camera);
	Line 93:         void CalculateFlareTransform(osg::Vec3 flarePos, float& flareRotation,
	Line 94:                                      float& flareLength, osg::Camera *camera);
	Line 95:         osg::ref_ptr<osg::Geometry> CreateFlareGeometry(std::string texturePath,
	Line 95:         osg::ref_ptr<osg::Geometry> CreateFlareGeometry(std::string texturePath,
	Line 101:         osg::ref_ptr<osg::Uniform> mFlareColorUniform;
	Line 101:         osg::ref_ptr<osg::Uniform> mFlareColorUniform;
	Line 102:         osg::ref_ptr<osg::Uniform> mFlareScaleUniform;
	Line 102:         osg::ref_ptr<osg::Uniform> mFlareScaleUniform;
	Line 103:         osg::ref_ptr<osg::MatrixTransform> mTransform;
	Line 103:         osg::ref_ptr<osg::MatrixTransform> mTransform;
  D:\Development\psim\src\subview\SunMoon.cpp (11 hits)
	Line 16: extern osg::ref_ptr<osg::Camera> mainCamera;
	Line 16: extern osg::ref_ptr<osg::Camera> mainCamera;
	Line 22: SunMoon::SunMoon(osg::Group *root)
	Line 38:     osg::ref_ptr<osg::Group> ephemerisGroup = new osg::Group;
	Line 38:     osg::ref_ptr<osg::Group> ephemerisGroup = new osg::Group;
	Line 38:     osg::ref_ptr<osg::Group> ephemerisGroup = new osg::Group;
	Line 65: osg::Vec3 SunMoon::GetMoonPos()
	Line 75: osg::Vec3 SunMoon::GetSunColor()
	Line 90: osg::Vec3 SunMoon::GetSunPos()
	Line 231: osg::Vec3 SunMoon::getOldSunPosVec()
	Line 256: osg::Vec3 SunMoon::GetBottomColor()
  D:\Development\psim\src\subview\SunMoon.h (6 hits)
	Line 13:         SunMoon(osg::Group *root);
	Line 23:         osg::Vec3 getOldSunPosVec();
	Line 33:         osg::Vec3 GetMoonPos();
	Line 36:         osg::Vec3 GetSunColor();
	Line 39:         osg::Vec3 GetSunPos();
	Line 41:         osg::Vec3 GetBottomColor();
  D:\Development\psim\src\subview\SunOcclusionQuery.cpp (35 hits)
	Line 44: , mSunTokenTransformPtr(new osg::MatrixTransform)
	Line 47:     osg::ref_ptr<osg::Cylinder> tokenShape = new osg::Cylinder(osg::Vec3(0.0, 0.0, 0.0), 0.25, 1.0);
	Line 47:     osg::ref_ptr<osg::Cylinder> tokenShape = new osg::Cylinder(osg::Vec3(0.0, 0.0, 0.0), 0.25, 1.0);
	Line 47:     osg::ref_ptr<osg::Cylinder> tokenShape = new osg::Cylinder(osg::Vec3(0.0, 0.0, 0.0), 0.25, 1.0);
	Line 47:     osg::ref_ptr<osg::Cylinder> tokenShape = new osg::Cylinder(osg::Vec3(0.0, 0.0, 0.0), 0.25, 1.0);
	Line 48:     osg::ref_ptr<osg::ShapeDrawable> tokenDrawable = new osg::ShapeDrawable(tokenShape);
	Line 48:     osg::ref_ptr<osg::ShapeDrawable> tokenDrawable = new osg::ShapeDrawable(tokenShape);
	Line 48:     osg::ref_ptr<osg::ShapeDrawable> tokenDrawable = new osg::ShapeDrawable(tokenShape);
	Line 49:     tokenDrawable->setColor(osg::Vec4(1.0, 0.0, 0.0, 0.0)); // the token should be invisible
	Line 50:     tokenShape->setRotation(*(new osg::Quat(0.5 * M_PI, osg::Vec3(1.0, 0.0, 0.0)))); // rotate the geometry so it appears to be a circle
	Line 50:     tokenShape->setRotation(*(new osg::Quat(0.5 * M_PI, osg::Vec3(1.0, 0.0, 0.0)))); // rotate the geometry so it appears to be a circle
	Line 53:     osg::ref_ptr<osg::Geode> sunToken = new osg::Geode();
	Line 53:     osg::ref_ptr<osg::Geode> sunToken = new osg::Geode();
	Line 53:     osg::ref_ptr<osg::Geode> sunToken = new osg::Geode();
	Line 58:     osg::ref_ptr<osg::StateSet> tokenStateset = sunToken->getOrCreateStateSet();
	Line 58:     osg::ref_ptr<osg::StateSet> tokenStateset = sunToken->getOrCreateStateSet();
	Line 60:     tokenStateset->setMode(GL_BLEND, osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);
	Line 60:     tokenStateset->setMode(GL_BLEND, osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);
	Line 63:     osg::ref_ptr<osg::Stencil> stencil = new osg::Stencil;
	Line 63:     osg::ref_ptr<osg::Stencil> stencil = new osg::Stencil;
	Line 63:     osg::ref_ptr<osg::Stencil> stencil = new osg::Stencil;
	Line 64:     stencil->setFunction(osg::Stencil::EQUAL, 0, 0x01);
	Line 67:     osg::ref_ptr<osg::StateSet> queryStateset = mFragQueryNodePtr->getQueryStateSet();
	Line 67:     osg::ref_ptr<osg::StateSet> queryStateset = mFragQueryNodePtr->getQueryStateSet();
	Line 68:     queryStateset->setAttributeAndModes(stencil, osg::StateAttribute::ON);
	Line 69:     queryStateset->setMode(GL_STENCIL_TEST, osg::StateAttribute::ON);
	Line 90: osg::Group* SunOcclusionQuery::GetNode()
	Line 95: int SunOcclusionQuery::GetOccludedPixels(osg::Camera *camera)
	Line 100: void SunOcclusionQuery::UpdateMatrix(float sunElevation, float sunAzimuth, float sunScale, osg::Vec3 sunPos)
	Line 104:             osg::Matrix::rotate(osg::inDegrees(sunElevation), 1.0f, 0.0f, 0.0f) *
	Line 104:             osg::Matrix::rotate(osg::inDegrees(sunElevation), 1.0f, 0.0f, 0.0f) *
	Line 105:             osg::Matrix::rotate(osg::inDegrees(sunAzimuth), 0.0f, 0.0f, 1.0f) *
	Line 105:             osg::Matrix::rotate(osg::inDegrees(sunAzimuth), 0.0f, 0.0f, 1.0f) *
	Line 106:             osg::Matrix::scale(sunScale, sunScale, sunScale) *
	Line 107:             osg::Matrix::translate(sunPos));
  D:\Development\psim\src\subview\SunOcclusionQuery.h (6 hits)
	Line 17:         osg::Group* GetNode();
	Line 18:         int GetOccludedPixels(osg::Camera *camera);
	Line 20:         void UpdateMatrix(float sunElevation, float sunAzimuth, float sunScale, osg::Vec3 sunPos);
	Line 23:         osg::ref_ptr<FragQueryNode> mFragQueryNodePtr;
	Line 24:         osg::ref_ptr<osg::MatrixTransform> mSunTokenTransformPtr;
	Line 24:         osg::ref_ptr<osg::MatrixTransform> mSunTokenTransformPtr;
  D:\Development\psim\src\subview\SwitchedEntity.cpp (56 hits)
	Line 26: void SwitchedEntity::operator()(osg::Node * node, osg::NodeVisitor * nv)
	Line 26: void SwitchedEntity::operator()(osg::Node * node, osg::NodeVisitor * nv)
	Line 37:                 ((osg::Switch *) node)->setAllChildrenOn();
	Line 41:                 ((osg::Switch *) node)->setAllChildrenOff();
	Line 48:                 ((osg::Switch *) node)->setAllChildrenOn();
	Line 52:                 ((osg::Switch *) node)->setAllChildrenOff();
	Line 57:             osg::Node * child = ((osg::Group*)node)->getChild(1);
	Line 57:             osg::Node * child = ((osg::Group*)node)->getChild(1);
	Line 60:                 ((osg::Switch *) node)->setAllChildrenOn();
	Line 64:                 ((osg::Switch *) node)->setAllChildrenOff();
	Line 71:                 ((osg::Switch *) node)->setAllChildrenOn();
	Line 75:                 ((osg::Switch *) node)->setAllChildrenOff();
	Line 84:             //    ((osg::Switch *) node)->setAllChildrenOn();
	Line 88:                 ((osg::Switch *) node)->setAllChildrenOff();
	Line 97:                 ((osg::Switch *) node)->setAllChildrenOn();
	Line 101:             //    ((osg::Switch *) node)->setAllChildrenOff();
	Line 109:                 ((osg::Switch *) node)->setAllChildrenOn();
	Line 113:                 ((osg::Switch *) node)->setAllChildrenOff();
	Line 121:                 ((osg::Switch *) node)->setAllChildrenOn();
	Line 125:                 ((osg::Switch *) node)->setAllChildrenOff();
	Line 134:                 ((osg::Switch *) node)->setAllChildrenOn();
	Line 138:                 ((osg::Switch *) node)->setAllChildrenOff();
	Line 147:                 ((osg::Switch *) node)->setAllChildrenOn();
	Line 151:                 ((osg::Switch *) node)->setAllChildrenOff();
	Line 159:                 ((osg::Switch *) node)->setAllChildrenOn();
	Line 163:                 ((osg::Switch *) node)->setAllChildrenOff();
	Line 171:                 ((osg::Switch *) node)->setAllChildrenOn();
	Line 175:                 ((osg::Switch *) node)->setAllChildrenOff();
	Line 183:                 ((osg::Switch *) node)->setAllChildrenOn();
	Line 187:                 ((osg::Switch *) node)->setAllChildrenOff();
	Line 195:                 ((osg::Switch *) node)->setAllChildrenOn();
	Line 199:                 ((osg::Switch *) node)->setAllChildrenOff();
	Line 208:                 ((osg::Switch *) node)->setAllChildrenOn();
	Line 212:                 ((osg::Switch *) node)->setAllChildrenOff();
	Line 219:                 ((osg::Switch *) node)->setAllChildrenOn();
	Line 223:                 ((osg::Switch *) node)->setAllChildrenOff();
	Line 230:                 ((osg::Switch *) node)->setAllChildrenOn();
	Line 234:                 ((osg::Switch *) node)->setAllChildrenOff();
	Line 241:                 ((osg::Switch *) node)->setAllChildrenOn();
	Line 245:                 ((osg::Switch *) node)->setAllChildrenOff();
	Line 252:                 ((osg::Switch *) node)->setAllChildrenOn();
	Line 256:                 ((osg::Switch *) node)->setAllChildrenOff();
	Line 263:                 ((osg::Switch *) node)->setAllChildrenOn();
	Line 267:                 ((osg::Switch *) node)->setAllChildrenOff();
	Line 274:                 ((osg::Switch *) node)->setAllChildrenOn();
	Line 278:                 ((osg::Switch *) node)->setAllChildrenOff();
	Line 288:                 ((osg::Switch *) node)->setAllChildrenOff();
	Line 292:                 ((osg::Switch *) node)->setAllChildrenOn();
	Line 301:                 ((osg::Switch *) node)->setAllChildrenOn();
	Line 305:                 ((osg::Switch *) node)->setAllChildrenOff();
	Line 314:                 ((osg::Switch *) node)->setAllChildrenOn();
	Line 318:                 ((osg::Switch *) node)->setAllChildrenOff();
	Line 327:                 ((osg::Switch *) node)->setAllChildrenOn();
	Line 331:                 ((osg::Switch *) node)->setAllChildrenOff();
	Line 404:             ((osg::Switch *) node)->setAllChildrenOn();
	Line 406:             ((osg::Switch *) node)->setAllChildrenOff();
  D:\Development\psim\src\subview\SwitchedEntity.h (3 hits)
	Line 9: class SwitchedEntity : public osg::NodeCallback
	Line 13:     virtual void operator()(osg::Node * node, osg::NodeVisitor * nv);
	Line 13:     virtual void operator()(osg::Node * node, osg::NodeVisitor * nv);
  D:\Development\psim\src\subview\TacDisp.cpp (13 hits)
	Line 30:         mFontColorDay = osg::Vec3(atoi(getenv("TAC_DISP_DAY_RED")),
	Line 36:         mFontColorNight = osg::Vec3(atoi(getenv("TAC_DISP_NIGHT_RED")),
	Line 67: void TacDisp::drawImplementation(osg::RenderInfo& ri) const
	Line 73: osg::Vec3 TacDisp::convertRGBToHSV(osg::Vec3 rgb)
	Line 73: osg::Vec3 TacDisp::convertRGBToHSV(osg::Vec3 rgb)
	Line 76:     osg::Vec3 hsv;
	Line 111: osg::Vec3 TacDisp::convertHSVToRGB(osg::Vec3 hsv)
	Line 111: osg::Vec3 TacDisp::convertHSVToRGB(osg::Vec3 hsv)
	Line 114:     osg::Vec3 rgb;
	Line 152: void TacDisp::draw(osg::RenderInfo& ri)
	Line 161:     osg::Vec3 hsv;
	Line 162:     osg::Vec3 rgb;
	Line 172:     hsv = convertRGBToHSV(osg::Vec3(rgb[0] / 255.f, rgb[1] / 255.f, rgb[2] / 255.f));
  D:\Development\psim\src\subview\TacDisp.h (8 hits)
	Line 17:     virtual void drawImplementation(osg::RenderInfo& ri) const;
	Line 20:     void draw(osg::RenderInfo& ri);
	Line 21:     osg::Vec3 convertRGBToHSV(osg::Vec3 rgb);
	Line 21:     osg::Vec3 convertRGBToHSV(osg::Vec3 rgb);
	Line 22:     osg::Vec3 convertHSVToRGB(osg::Vec3 hsv);
	Line 22:     osg::Vec3 convertHSVToRGB(osg::Vec3 hsv);
	Line 25:     osg::Vec3 mFontColorDay;
	Line 26:     osg::Vec3 mFontColorNight;
  D:\Development\psim\src\subview\Telemeter.cpp (14 hits)
	Line 14: Telemeter::Telemeter(const Telemeter& Telemeter, const osg::CopyOp& copyop/* = osg::CopyOp::SHALLOW_COPY*/) :
	Line 14: Telemeter::Telemeter(const Telemeter& Telemeter, const osg::CopyOp& copyop/* = osg::CopyOp::SHALLOW_COPY*/) :
	Line 15: osg::Geometry(Telemeter, copyop)
	Line 56: osg::BoundingBox Telemeter::computeBound() const
	Line 58:     osg::BoundingBox bbox;
	Line 59:     bbox.expandBy(osg::Vec3(-10000.f, -10000.f, -10000.f));
	Line 60:     bbox.expandBy(osg::Vec3(10000.f, 10000.f, 10000.f));
	Line 64: void Telemeter::addToOSG(osg::Group * root)
	Line 66:     osg::ref_ptr<osg::Geode> geode = new osg::Geode();
	Line 66:     osg::ref_ptr<osg::Geode> geode = new osg::Geode();
	Line 66:     osg::ref_ptr<osg::Geode> geode = new osg::Geode();
	Line 72: void Telemeter::addDrawable(osg::Geode *geode)
	Line 77: void Telemeter::removeDrawable(osg::Geode *geode)
	Line 82: void Telemeter::drawImplementation(osg::RenderInfo& ri) const
  D:\Development\psim\src\subview\Telemeter.h (24 hits)
	Line 23: class Telemeter : public osg::Geometry
	Line 28:     Telemeter(const Telemeter& Telemeter, const osg::CopyOp& copyop = osg::CopyOp::SHALLOW_COPY);
	Line 28:     Telemeter(const Telemeter& Telemeter, const osg::CopyOp& copyop = osg::CopyOp::SHALLOW_COPY);
	Line 31:     virtual osg::BoundingBox computeBound() const;
	Line 35:     virtual void drawImplementation(osg::RenderInfo& ri) const;
	Line 36:     void addToOSG(osg::Group * root);
	Line 38:     virtual void addDrawable(osg::Geode *geode);
	Line 39:     virtual void removeDrawable(osg::Geode *geode);
	Line 57:     osg::ref_ptr<osg::RefMatrix> sProjectionMatrix;
	Line 57:     osg::ref_ptr<osg::RefMatrix> sProjectionMatrix;
	Line 58:     osg::ref_ptr<osg::RefMatrix> sModelviewMatrix;
	Line 58:     osg::ref_ptr<osg::RefMatrix> sModelviewMatrix;
	Line 59:     osg::ref_ptr<osg::StateSet> stateSet;
	Line 59:     osg::ref_ptr<osg::StateSet> stateSet;
	Line 60:     osg::ref_ptr<osg::Uniform> textureEnabledUniform;
	Line 60:     osg::ref_ptr<osg::Uniform> textureEnabledUniform;
	Line 61:     osg::ref_ptr<osg::Uniform> redUniform;
	Line 61:     osg::ref_ptr<osg::Uniform> redUniform;
	Line 62:     osg::ref_ptr<osg::Uniform> greenUniform;
	Line 62:     osg::ref_ptr<osg::Uniform> greenUniform;
	Line 63:     osg::ref_ptr<osg::Uniform> blueUniform;
	Line 63:     osg::ref_ptr<osg::Uniform> blueUniform;
	Line 64:     osg::ref_ptr<osg::Uniform> alphaUniform;
	Line 64:     osg::ref_ptr<osg::Uniform> alphaUniform;
  D:\Development\psim\src\subview\Terrain.cpp (41 hits)
	Line 41: Terrain::Terrain(const Terrain& Terrain, const osg::CopyOp& copyop/* = osg::CopyOp::SHALLOW_COPY*/) :
	Line 41: Terrain::Terrain(const Terrain& Terrain, const osg::CopyOp& copyop/* = osg::CopyOp::SHALLOW_COPY*/) :
	Line 42: osg::Geode(Terrain, copyop)
	Line 50: Terrain::Terrain(osg::Camera *c) :
	Line 118:     osg::ref_ptr<osg::Geometry> defaultDrawable = new TerrainDrawable(this, -1, this->getNumDrawables() + 1);
	Line 118:     osg::ref_ptr<osg::Geometry> defaultDrawable = new TerrainDrawable(this, -1, this->getNumDrawables() + 1);
	Line 146:     texmat = new osg::TexMat;
	Line 147:     texmat->setMatrix(osg::Matrix::translate(0., 0., 0.));
	Line 169:     osg::ref_ptr<TerrainDrawable> curDrawable;
	Line 202:     osg::ref_ptr<osg::Geometry> newDrawable;
	Line 202:     osg::ref_ptr<osg::Geometry> newDrawable;
	Line 212:     osg::Vec3f eye, center, dir, up;
	Line 216:     osg::Matrixf view = camera->getViewMatrix();
	Line 261: void Terrain::addToOSG(osg::Group * root)
	Line 268:     stateSet = new osg::StateSet;
	Line 271:     rockTexSampler = new osg::Uniform("RockTex", 0);
	Line 272:     sandTexSampler = new osg::Uniform("SandTex", 1);
	Line 273:     grassTexSampler = new osg::Uniform("GrassTex", 2);
	Line 274:     forestTexSampler = new osg::Uniform("ForestTex", 3);
	Line 275:     texIDUniform = new osg::Uniform("texID", -1.0f);
	Line 278:     maxSunZUniform = new osg::Uniform("maxSunZ", 0.0f);
	Line 279:     curTimeInDarkUniform = new osg::Uniform("curTimeInDark", 0.0f);
	Line 280:     totalTimeInDarkUniform = new osg::Uniform("totalTimeInDark", 0.0f);
	Line 283:     distanceEWUniform = new osg::Uniform("distanceEW", 0.f);
	Line 284:     distanceNSUniform = new osg::Uniform("distanceNS", 0.f);
	Line 285:     scopeElevationUniform = new osg::Uniform("scopeElevation", 0.f);
	Line 286:     oldSunPosUniform = new osg::Uniform("oldSunPos", osg::Vec3(0, 1, 0));
	Line 286:     oldSunPosUniform = new osg::Uniform("oldSunPos", osg::Vec3(0, 1, 0));
	Line 305:     stateSet->setTextureAttributeAndModes(0, texmat.get(), osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);
	Line 305:     stateSet->setTextureAttributeAndModes(0, texmat.get(), osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);
	Line 306:     stateSet->setTextureAttributeAndModes(0, RockTex, osg::StateAttribute::ON);
	Line 307:     stateSet->setTextureAttributeAndModes(1, SandTex, osg::StateAttribute::ON);
	Line 308:     stateSet->setTextureAttributeAndModes(2, GrassTex, osg::StateAttribute::ON);
	Line 309:     stateSet->setTextureAttributeAndModes(3, ForestTex, osg::StateAttribute::ON);
	Line 312:     osg::ref_ptr<osg::Program> program = new osg::Program;
	Line 312:     osg::ref_ptr<osg::Program> program = new osg::Program;
	Line 312:     osg::ref_ptr<osg::Program> program = new osg::Program;
	Line 315:     program->addShader(ShaderMaster::getInstance().createShader(osg::Shader::VERTEX, "terrainVert.glsl"));
	Line 316:     program->addShader(ShaderMaster::getInstance().createShader(osg::Shader::FRAGMENT, "terrainFrag.glsl"));
	Line 322:     stateSet->setAttributeAndModes(program.get(), osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);
	Line 322:     stateSet->setAttributeAndModes(program.get(), osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);
  D:\Development\psim\src\subview\Terrain.h (44 hits)
	Line 22: class Terrain : public osg::Geode
	Line 27:     Terrain(const Terrain& Terrain, const osg::CopyOp& copyop = osg::CopyOp::SHALLOW_COPY);
	Line 27:     Terrain(const Terrain& Terrain, const osg::CopyOp& copyop = osg::CopyOp::SHALLOW_COPY);
	Line 30:     Terrain(osg::Camera *camera);
	Line 39:     void addToOSG(osg::Group * root);
	Line 50:     osg::Camera *camera;
	Line 53:     osg::ref_ptr<osg::Texture2D> RockTex;
	Line 53:     osg::ref_ptr<osg::Texture2D> RockTex;
	Line 54:     osg::ref_ptr<osg::Texture2D> SandTex;
	Line 54:     osg::ref_ptr<osg::Texture2D> SandTex;
	Line 55:     osg::ref_ptr<osg::Texture2D> GrassTex;
	Line 55:     osg::ref_ptr<osg::Texture2D> GrassTex;
	Line 56:     osg::ref_ptr<osg::Texture2D> ForestTex;
	Line 56:     osg::ref_ptr<osg::Texture2D> ForestTex;
	Line 57:     osg::ref_ptr<osg::TexMat> texmat;
	Line 57:     osg::ref_ptr<osg::TexMat> texmat;
	Line 91:     osg::ref_ptr<osg::StateSet> stateSet;
	Line 91:     osg::ref_ptr<osg::StateSet> stateSet;
	Line 93:     //osg::ref_ptr<osg::Uniform> texSampler;
	Line 93:     //osg::ref_ptr<osg::Uniform> texSampler;
	Line 94:     osg::ref_ptr<osg::Uniform> rockTexSampler;
	Line 94:     osg::ref_ptr<osg::Uniform> rockTexSampler;
	Line 95:     osg::ref_ptr<osg::Uniform> sandTexSampler;
	Line 95:     osg::ref_ptr<osg::Uniform> sandTexSampler;
	Line 96:     osg::ref_ptr<osg::Uniform> grassTexSampler;
	Line 96:     osg::ref_ptr<osg::Uniform> grassTexSampler;
	Line 97:     osg::ref_ptr<osg::Uniform> forestTexSampler;
	Line 97:     osg::ref_ptr<osg::Uniform> forestTexSampler;
	Line 98:     osg::ref_ptr<osg::Uniform> texIDUniform;
	Line 98:     osg::ref_ptr<osg::Uniform> texIDUniform;
	Line 99:     osg::ref_ptr<osg::Uniform> maxSunZUniform;
	Line 99:     osg::ref_ptr<osg::Uniform> maxSunZUniform;
	Line 100:     osg::ref_ptr<osg::Uniform> curTimeInDarkUniform;
	Line 100:     osg::ref_ptr<osg::Uniform> curTimeInDarkUniform;
	Line 101:     osg::ref_ptr<osg::Uniform> totalTimeInDarkUniform;
	Line 101:     osg::ref_ptr<osg::Uniform> totalTimeInDarkUniform;
	Line 102:     osg::ref_ptr<osg::Uniform> distanceEWUniform;
	Line 102:     osg::ref_ptr<osg::Uniform> distanceEWUniform;
	Line 103:     osg::ref_ptr<osg::Uniform> distanceNSUniform;
	Line 103:     osg::ref_ptr<osg::Uniform> distanceNSUniform;
	Line 104:     osg::ref_ptr<osg::Uniform> scopeElevationUniform;
	Line 104:     osg::ref_ptr<osg::Uniform> scopeElevationUniform;
	Line 105:     osg::ref_ptr<osg::Uniform> oldSunPosUniform;
	Line 105:     osg::ref_ptr<osg::Uniform> oldSunPosUniform;
  D:\Development\psim\src\subview\TerrainBuffer.cpp (2 hits)
	Line 136: void TerrainBuffer::draw(int texID, osg::RenderInfo& ri)
	Line 144:         osg::State & state = *ri.getState();
  D:\Development\psim\src\subview\TerrainBuffer.h (1 hit)
	Line 25:     void draw(int texID, osg::RenderInfo& ri);
  D:\Development\psim\src\subview\TerrainDrawable.cpp (20 hits)
	Line 25: TerrainDrawable::TerrainDrawable(const TerrainDrawable& TerrainDrawable, const osg::CopyOp& copyop/* = osg::CopyOp::SHALLOW_COPY*/) :
	Line 25: TerrainDrawable::TerrainDrawable(const TerrainDrawable& TerrainDrawable, const osg::CopyOp& copyop/* = osg::CopyOp::SHALLOW_COPY*/) :
	Line 26: osg::Geometry(TerrainDrawable, copyop)
	Line 78: osg::BoundingBox TerrainDrawable::computeBound() const
	Line 80:     osg::BoundingBox bbox;
	Line 81:     bbox.expandBy(osg::Vec3(-100000.f, -100000.f, -100000.f));
	Line 82:     bbox.expandBy(osg::Vec3(100000.f, 100000.f, 100000.f));
	Line 105:     offsetUniform->set(osg::Vec3(-1. * (0.5 + shaderDistanceEW * centerXYZ[0]), -1. * shaderDistanceNS * centerXYZ[1], 1.));
	Line 120: void TerrainDrawable::drawImplementation(osg::RenderInfo& ri) const
	Line 142:                 osg::ref_ptr<osg::State> state = ri.getState();
	Line 142:                 osg::ref_ptr<osg::State> state = ri.getState();
	Line 193:     mStateSet = new osg::StateSet;
	Line 195:     offsetUniform = new osg::Uniform("offset", osg::Vec3(centerXYZ[0], centerXYZ[1], 1.));
	Line 195:     offsetUniform = new osg::Uniform("offset", osg::Vec3(centerXYZ[0], centerXYZ[1], 1.));
	Line 197:     distanceNSUniform = new osg::Uniform("distanceNS", shaderDistanceNS);
	Line 198:     distanceEWUniform = new osg::Uniform("distanceEW", shaderDistanceEW);
	Line 207:         satImageryTexSampler = new osg::Uniform("SatImageryTex", 4);
	Line 208:         texIDUniform = new osg::Uniform("texID", float(mTexID));
	Line 213:         mStateSet->setTextureAttributeAndModes(4, mTexture, osg::StateAttribute::ON | osg::StateAttribute::PROTECTED);
	Line 213:         mStateSet->setTextureAttributeAndModes(4, mTexture, osg::StateAttribute::ON | osg::StateAttribute::PROTECTED);
  D:\Development\psim\src\subview\TerrainDrawable.h (19 hits)
	Line 17: class TerrainDrawable : public osg::Geometry
	Line 22:     TerrainDrawable(const TerrainDrawable& TerrainDrawable, const osg::CopyOp& copyop = osg::CopyOp::SHALLOW_COPY);
	Line 22:     TerrainDrawable(const TerrainDrawable& TerrainDrawable, const osg::CopyOp& copyop = osg::CopyOp::SHALLOW_COPY);
	Line 26:     virtual osg::BoundingBox computeBound() const;
	Line 30:     void drawImplementation(osg::RenderInfo& ri) const;
	Line 56:     osg::ref_ptr<osg::Texture2D> mTexture;
	Line 56:     osg::ref_ptr<osg::Texture2D> mTexture;
	Line 57:     osg::ref_ptr<osg::Uniform> satImageryTexSampler;
	Line 57:     osg::ref_ptr<osg::Uniform> satImageryTexSampler;
	Line 58:     osg::ref_ptr<osg::Uniform> texIDUniform;
	Line 58:     osg::ref_ptr<osg::Uniform> texIDUniform;
	Line 59:     osg::ref_ptr<osg::Uniform> distanceNSUniform;
	Line 59:     osg::ref_ptr<osg::Uniform> distanceNSUniform;
	Line 60:     osg::ref_ptr<osg::Uniform> distanceEWUniform;
	Line 60:     osg::ref_ptr<osg::Uniform> distanceEWUniform;
	Line 61:     osg::ref_ptr<osg::Uniform> offsetUniform;
	Line 61:     osg::ref_ptr<osg::Uniform> offsetUniform;
	Line 64:     osg::ref_ptr<osg::StateSet> mStateSet;
	Line 64:     osg::ref_ptr<osg::StateSet> mStateSet;
  D:\Development\psim\src\subview\TerrainMeshGenerator.cpp (5 hits)
	Line 34: TerrainMeshGenerator::TerrainMeshGenerator(Terrain* pTerrain, double lat, double lon, ViewSpecShared* pCurrentViewSpec, osg::Camera *c) :
	Line 582:     osg::Vec3f eye, center, up;
	Line 583:     osg::Matrixf view;
	Line 599:     osg::Vec3f eye, center, up;
	Line 600:     osg::Matrixf view;
  D:\Development\psim\src\subview\TerrainMeshGenerator.h (2 hits)
	Line 20:     TerrainMeshGenerator(Terrain* pTerrain, double lat, double lon, ViewSpecShared* pCurrentViewSpec, osg::Camera *c);
	Line 58:     osg::Camera *camera;
  D:\Development\psim\src\subview\test\ShipWakes.cc (6 hits)
	Line 51:   void updateDynamicWake(Sub* vehicle, float speed, osg::Vec3f pos)
	Line 56:   void updateDynamicWakeSteadyState(Sub* vehicle, float speed, osg::Vec3f pos, int num_iterations) // forces the wake to update num_iterations times so it reaches a constant value after filtering
	Line 117:   updateDynamicWakeSteadyState(os, 10.0f, osg::Vec3f(0.0,0.0,0.0), 200);
	Line 142:   updateDynamicWake(os, 10.0f, osg::Vec3f(0.0,0.0,0.0));
	Line 143:   updateDynamicWake(other_sub, 10.0f, osg::Vec3f(10.0,0.0,0.0));
	Line 170:   updateDynamicWake(other_sub, 10.0f, osg::Vec3f(10.0,0.0,0.0));
  D:\Development\psim\src\subview\TexCamUpdateCallback.cpp (8 hits)
	Line 21: extern osg::TexMat* projTexMat;
	Line 23: TexCamUpdateCallback::TexCamUpdateCallback(osg::ref_ptr<osg::Camera> mainCamera) :
	Line 23: TexCamUpdateCallback::TexCamUpdateCallback(osg::ref_ptr<osg::Camera> mainCamera) :
	Line 29: void TexCamUpdateCallback::operator()(osg::Node* node, osg::NodeVisitor* nv)
	Line 29: void TexCamUpdateCallback::operator()(osg::Node* node, osg::NodeVisitor* nv)
	Line 31:     osg::Camera* texCam = dynamic_cast<osg::Camera*> (node); // dynamic cast will return null if node isn't a camera
	Line 31:     osg::Camera* texCam = dynamic_cast<osg::Camera*> (node); // dynamic cast will return null if node isn't a camera
	Line 69:                 projTexMat = new osg::TexMat();
  D:\Development\psim\src\subview\TexCamUpdateCallback.h (7 hits)
	Line 16: class TexCamUpdateCallback : public osg::NodeCallback
	Line 19:     TexCamUpdateCallback(osg::ref_ptr<osg::Camera> mainCamera);
	Line 19:     TexCamUpdateCallback(osg::ref_ptr<osg::Camera> mainCamera);
	Line 21:     virtual void operator()(osg::Node* node, osg::NodeVisitor* nv);
	Line 21:     virtual void operator()(osg::Node* node, osg::NodeVisitor* nv);
	Line 24:     osg::ref_ptr<osg::Camera> mMainCamera;
	Line 24:     osg::ref_ptr<osg::Camera> mMainCamera;
  D:\Development\psim\src\subview\TextBox.cpp (18 hits)
	Line 19: TextBox::TextBox(osg::Geode * node, std::string fontPath, osg::Vec4 color)
	Line 19: TextBox::TextBox(osg::Geode * node, std::string fontPath, osg::Vec4 color)
	Line 23:     node->getOrCreateStateSet()->setAttributeAndModes(new osg::Program(),
	Line 24:             osg::StateAttribute::ON
	Line 25:             | osg::StateAttribute::PROTECTED);
	Line 27:     osg::BoundingBox bb = node->getDrawable(0)->getBound();
	Line 28:     osg::Vec3 upperLeftCorner = bb.corner(6);
	Line 35:     osg::Vec3 position;
	Line 45:     mText->getOrCreateStateSet()->setDataVariance(osg::Object::DYNAMIC);
	Line 63:     //mText->setRotation(osg::Quat(w, x, y, z));
	Line 65:     osg::Quat quat1, quat2, quatFinal;
	Line 66:     quat1.makeRotate(270 * M_PI / 180, osg::Vec3(0, 0, 1));
	Line 67:     quat2.makeRotate(65 * M_PI / 180, osg::Vec3(1, 0, 0)); //rotations of bridge box
	Line 78: void TextBox::operator()(osg::Node* node, osg::NodeVisitor* nv)
	Line 78: void TextBox::operator()(osg::Node* node, osg::NodeVisitor* nv)
	Line 84: void TextBox::setText(osg::Node *node)
	Line 86:     osg::Geode* geode = dynamic_cast<osg::Geode*> (node);
	Line 86:     osg::Geode* geode = dynamic_cast<osg::Geode*> (node);
  D:\Development\psim\src\subview\TextBox.h (7 hits)
	Line 13: class TextBox : public osg::NodeCallback
	Line 17:     TextBox(osg::Geode * node, std::string fontPath, osg::Vec4 color);
	Line 17:     TextBox(osg::Geode * node, std::string fontPath, osg::Vec4 color);
	Line 21:     virtual void operator()(osg::Node* node, osg::NodeVisitor* nv);
	Line 21:     virtual void operator()(osg::Node* node, osg::NodeVisitor* nv);
	Line 23:     void setText(osg::Node *node);
	Line 28:     osg::ref_ptr<osgText::Text> mText;
  D:\Development\psim\src\subview\TexturedQuadLightsManager.cpp (50 hits)
	Line 35:     blend = new osg::BlendFunc;
	Line 36:     blend->setFunction(osg::BlendFunc::DST_ALPHA, osg::BlendFunc::ONE);
	Line 36:     blend->setFunction(osg::BlendFunc::DST_ALPHA, osg::BlendFunc::ONE);
	Line 37:     blend->setFunction(osg::BlendFunc::SRC_ALPHA, osg::BlendFunc::ONE_MINUS_SRC_ALPHA);
	Line 37:     blend->setFunction(osg::BlendFunc::SRC_ALPHA, osg::BlendFunc::ONE_MINUS_SRC_ALPHA);
	Line 40:     depth = new osg::Depth;
	Line 44:     tex1 = new osg::Texture2D;
	Line 46:     tex1->setFilter(osg::Texture2D::MIN_FILTER, osg::Texture2D::LINEAR_MIPMAP_LINEAR);
	Line 46:     tex1->setFilter(osg::Texture2D::MIN_FILTER, osg::Texture2D::LINEAR_MIPMAP_LINEAR);
	Line 47:     tex1->setFilter(osg::Texture2D::MAG_FILTER, osg::Texture2D::LINEAR);
	Line 47:     tex1->setFilter(osg::Texture2D::MAG_FILTER, osg::Texture2D::LINEAR);
	Line 48:     tex1->setWrap(osg::Texture2D::WRAP_S, osg::Texture2D::CLAMP_TO_EDGE);
	Line 48:     tex1->setWrap(osg::Texture2D::WRAP_S, osg::Texture2D::CLAMP_TO_EDGE);
	Line 49:     tex1->setWrap(osg::Texture2D::WRAP_T, osg::Texture2D::CLAMP_TO_EDGE);
	Line 49:     tex1->setWrap(osg::Texture2D::WRAP_T, osg::Texture2D::CLAMP_TO_EDGE);
	Line 52:     tex2 = new osg::Texture2D;
	Line 54:     tex2->setFilter(osg::Texture2D::MIN_FILTER, osg::Texture2D::LINEAR_MIPMAP_LINEAR);
	Line 54:     tex2->setFilter(osg::Texture2D::MIN_FILTER, osg::Texture2D::LINEAR_MIPMAP_LINEAR);
	Line 55:     tex2->setFilter(osg::Texture2D::MAG_FILTER, osg::Texture2D::LINEAR);
	Line 55:     tex2->setFilter(osg::Texture2D::MAG_FILTER, osg::Texture2D::LINEAR);
	Line 56:     tex2->setWrap(osg::Texture2D::WRAP_S, osg::Texture2D::CLAMP_TO_EDGE);
	Line 56:     tex2->setWrap(osg::Texture2D::WRAP_S, osg::Texture2D::CLAMP_TO_EDGE);
	Line 57:     tex2->setWrap(osg::Texture2D::WRAP_T, osg::Texture2D::CLAMP_TO_EDGE);
	Line 57:     tex2->setWrap(osg::Texture2D::WRAP_T, osg::Texture2D::CLAMP_TO_EDGE);
	Line 61:     lightSystemProgram = new osg::Program;
	Line 62:     lightSystemProgram->addShader(ShaderMaster::getInstance().createShader(osg::Shader::VERTEX, lightVertShader));
	Line 63:     lightSystemProgram->addShader(ShaderMaster::getInstance().createShader(osg::Shader::FRAGMENT, lightFragShader));
	Line 80: void TexturedQuadLightsManager::createLightSystem(osg::Geode & geode, ParseInstanceVisitor & visitor)
	Line 83:     osg::ref_ptr<LightSystemStateSetUpdate> lsssu = new LightSystemStateSetUpdate(visitor);
	Line 87:     osg::ref_ptr<osg::StateSet> ss = new osg::StateSet;
	Line 87:     osg::ref_ptr<osg::StateSet> ss = new osg::StateSet;
	Line 87:     osg::ref_ptr<osg::StateSet> ss = new osg::StateSet;
	Line 92:         //ss->setDataVariance(osg::Object::DYNAMIC);
	Line 95:         ss->setMode(GL_LIGHTING, osg::StateAttribute::OFF);
	Line 101:         ss->setAttributeAndModes(TexturedQuadLightsManager::getInstance()->blend, osg::StateAttribute::ON);
	Line 104:         ss->setAttributeAndModes(TexturedQuadLightsManager::getInstance()->depth, osg::StateAttribute::ON);
	Line 107:         ss->setMode(GL_SAMPLE_ALPHA_TO_COVERAGE, osg::StateAttribute::OFF | osg::StateAttribute::PROTECTED);
	Line 107:         ss->setMode(GL_SAMPLE_ALPHA_TO_COVERAGE, osg::StateAttribute::OFF | osg::StateAttribute::PROTECTED);
	Line 110:         //ss->setAttributeAndModes (TexturedQuadLightsManager::getInstance ()->po, osg::StateAttribute::ON);
	Line 113:         ss->setTextureAttributeAndModes(0, TexturedQuadLightsManager::getInstance()->tex1, osg::StateAttribute::ON);
	Line 114:         ss->addUniform(new osg::Uniform("myTex", 0));
	Line 115:         ss->setTextureAttributeAndModes(1, TexturedQuadLightsManager::getInstance()->tex2, osg::StateAttribute::ON);
	Line 116:         ss->addUniform(new osg::Uniform("myTexFog", 1));
	Line 122:         ss->addUniform(new osg::Uniform("hullDown", visitor.getVehicle()->isEDGEContact() || visitor.getVehicle()->getType() == VehicleType::HARBOR));
	Line 134:     osg::ref_ptr<LightSystemUpdate> lsu = new LightSystemUpdate(visitor);
	Line 138:     osg::ref_ptr<osg::Geometry> lightSystem = new osg::Geometry;
	Line 138:     osg::ref_ptr<osg::Geometry> lightSystem = new osg::Geometry;
	Line 138:     osg::ref_ptr<osg::Geometry> lightSystem = new osg::Geometry;
	Line 147:         lightSystem->setColorBinding(osg::Geometry::BIND_PER_VERTEX);
	Line 150:         lightSystem->setSecondaryColorBinding(osg::Geometry::BIND_PER_VERTEX);
  D:\Development\psim\src\subview\TexturedQuadLightsManager.h (15 hits)
	Line 26:     void createLightSystem(osg::Geode &, ParseInstanceVisitor &);
	Line 28:     osg::ref_ptr<osg::BlendFunc> blend;
	Line 28:     osg::ref_ptr<osg::BlendFunc> blend;
	Line 29:     osg::ref_ptr<osg::Depth> depth;
	Line 29:     osg::ref_ptr<osg::Depth> depth;
	Line 30:     osg::ref_ptr<osg::PolygonOffset> po;
	Line 30:     osg::ref_ptr<osg::PolygonOffset> po;
	Line 31:     osg::ref_ptr<osg::Texture2D> tex1;
	Line 31:     osg::ref_ptr<osg::Texture2D> tex1;
	Line 32:     osg::ref_ptr<osg::Texture2D> tex2;
	Line 32:     osg::ref_ptr<osg::Texture2D> tex2;
	Line 33:     osg::ref_ptr<osg::Program> lightSystemProgram;
	Line 33:     osg::ref_ptr<osg::Program> lightSystemProgram;
	Line 36:     osg::ref_ptr<osg::Texture2D> shapes;
	Line 36:     osg::ref_ptr<osg::Texture2D> shapes;
  D:\Development\psim\src\subview\TextureTelemeter.cpp (7 hits)
	Line 46: void TextureTelemeter::addDrawable(osg::Geode * geode)
	Line 52: void TextureTelemeter::removeDrawable(osg::Geode *geode)
	Line 64: void TextureTelemeter::drawImplementation(osg::RenderInfo& ri) const
	Line 92:     stateSet = new osg::StateSet;
	Line 94:     stateSet->setTextureAttributeAndModes(0, NULL, osg::StateAttribute::OFF | osg::StateAttribute::OVERRIDE);
	Line 94:     stateSet->setTextureAttributeAndModes(0, NULL, osg::StateAttribute::OFF | osg::StateAttribute::OVERRIDE);
	Line 97:     stateSet->setMode(GL_DEPTH_TEST, osg::StateAttribute::OFF);
  D:\Development\psim\src\subview\TextureTelemeter.h (3 hits)
	Line 24:     virtual void addDrawable(osg::Geode * geode);
	Line 25:     virtual void removeDrawable(osg::Geode *geode);
	Line 28:     virtual void drawImplementation(osg::RenderInfo& ri) const;
  D:\Development\psim\src\subview\TimeDB.cpp (5 hits)
	Line 24: TimeDB::TimeDB(Vehicle* vehicle, osg::Geode *node) :
	Line 25: TextBox(node, "msttcore/consola.ttf", osg::Vec4(1.f, 1.f, 1.f, 1.f)),
	Line 26: //TextBox(node, "gnu-free/FreeMonoBold.ttf", osg::Vec4(0.f, 0.f, 0.f, 1.f) ),
	Line 31: void TimeDB::operator()(osg::Node * node, osg::NodeVisitor * nv)
	Line 31: void TimeDB::operator()(osg::Node * node, osg::NodeVisitor * nv)
  D:\Development\psim\src\subview\TimeDB.h (3 hits)
	Line 21:     TimeDB(Vehicle* vehicle, osg::Geode *node);
	Line 23:     virtual void operator()(osg::Node * node, osg::NodeVisitor * nv);
	Line 23:     virtual void operator()(osg::Node * node, osg::NodeVisitor * nv);
  D:\Development\psim\src\subview\UAVOverlay.cpp (63 hits)
	Line 27: extern osg::ref_ptr<osg::Camera> mainCamera;
	Line 27: extern osg::ref_ptr<osg::Camera> mainCamera;
	Line 45:     stateSet = new osg::StateSet;
	Line 48:     stateSet->setMode(GL_DEPTH_TEST, osg::StateAttribute::OFF);
	Line 59:     overlayInitialization(&mAltitudeAxis, (char*) "uav/vertical_line_1", osg::Vec3(255, 255, 255));
	Line 60:     overlayInitialization(&mCamOrient, (char*) "uav/large_arrow_1", osg::Vec3(255, 153, 0)); //Orange
	Line 61:     overlayInitialization(&mCommandedElev, (char*) "uav/small_arrow_1", osg::Vec3(0, 255, 0));
	Line 62:     overlayInitialization(&mHeadingToHome, (char*) "uav/half_line_three_quarters", osg::Vec3(255, 75, 170)); //Pink
	Line 63:     overlayInitialization(&mHeadingToTarget, (char*) "uav/half_line_full", osg::Vec3(255, 0, 0));
	Line 64:     overlayInitialization(&mHomeElev, (char*) "uav/small_arrow_1", osg::Vec3(255, 75, 170)); //Pink
	Line 65:     overlayInitialization(&mHorizonLine, (char*) "uav/vertical_line_3", osg::Vec3(255, 255, 255));
	Line 66:     overlayInitialization(&mNonOptRange, (char*) "uav/vertical_line_2", osg::Vec3(255, 0, 0));
	Line 67:     overlayInitialization(&mOptRange, (char*) "uav/vertical_line_2", osg::Vec3(0, 255, 0));
	Line 68:     overlayInitialization(&mTargetElev, (char*) "uav/small_arrow_1", osg::Vec3(255, 0, 0));
	Line 69:     overlayInitialization(&mUAVAlt, (char*) "uav/small_arrow_1", osg::Vec3(255, 153, 0)); //Orange
	Line 70:     overlayInitialization(&mUAVHeading, (char*) "uav/half_line_half", osg::Vec3(255, 255, 255));
	Line 71:     overlayInitialization(&mWindHeading, (char*) "uav/wind_baseline", osg::Vec3(0, 255, 255)); //Cyan
	Line 74: void UAVOverlay::overlayInitialization(OverlayTexture* overlay, char* overlayLoc, osg::Vec3 rgb)
	Line 84: void UAVOverlay::addDrawable(osg::Geode * geode)
	Line 102: void UAVOverlay::addToOSG(osg::Group * root)
	Line 104:     osg::ref_ptr<osg::Geode> geode = new osg::Geode();
	Line 104:     osg::ref_ptr<osg::Geode> geode = new osg::Geode();
	Line 104:     osg::ref_ptr<osg::Geode> geode = new osg::Geode();
	Line 276: void UAVOverlay::drawImplementation(osg::RenderInfo& ri) const
	Line 281: void UAVOverlay::draw(osg::RenderInfo& ri)
	Line 435: void UAVOverlay::drawHorizonLine(osg::RenderInfo& ri)
	Line 444:     osg::Vec2 point1 = osg::Vec2(-lineWidth, vertOffset);
	Line 444:     osg::Vec2 point1 = osg::Vec2(-lineWidth, vertOffset);
	Line 445:     osg::Vec2 point2 = osg::Vec2(lineWidth, vertOffset);
	Line 445:     osg::Vec2 point2 = osg::Vec2(lineWidth, vertOffset);
	Line 450: osg::Vec4 UAVOverlay::pitchRollRotations(osg::Vec2 point1, osg::Vec2 point2, osg::RenderInfo& ri)
	Line 450: osg::Vec4 UAVOverlay::pitchRollRotations(osg::Vec2 point1, osg::Vec2 point2, osg::RenderInfo& ri)
	Line 450: osg::Vec4 UAVOverlay::pitchRollRotations(osg::Vec2 point1, osg::Vec2 point2, osg::RenderInfo& ri)
	Line 450: osg::Vec4 UAVOverlay::pitchRollRotations(osg::Vec2 point1, osg::Vec2 point2, osg::RenderInfo& ri)
	Line 456:     osg::State &state = *ri.getState();
	Line 457:     osg::Matrixd viewMatrix = mainCamera->getViewMatrix();
	Line 458:     osg::Matrixd projectionMatrix = state.getProjectionMatrix();
	Line 459:     osg::Matrixd windowMatrix = mainCamera->getViewport()->computeWindowMatrix();
	Line 460:     osg::Matrixd inverseViewMatrix = osg::Matrixd::inverse(viewMatrix);
	Line 460:     osg::Matrixd inverseViewMatrix = osg::Matrixd::inverse(viewMatrix);
	Line 461:     osg::Matrixd inverseProjectionMatrix = osg::Matrixd::inverse(projectionMatrix);
	Line 461:     osg::Matrixd inverseProjectionMatrix = osg::Matrixd::inverse(projectionMatrix);
	Line 462:     osg::Matrixd inverseWindowMatrix = osg::Matrixd::inverse(windowMatrix);
	Line 462:     osg::Matrixd inverseWindowMatrix = osg::Matrixd::inverse(windowMatrix);
	Line 463:     osg::Matrixd rotationMatrix;
	Line 466:     osg::Vec4 point1Screen = osg::Vec4(point1.x(), point1.y(), 0.0, 1.0);
	Line 466:     osg::Vec4 point1Screen = osg::Vec4(point1.x(), point1.y(), 0.0, 1.0);
	Line 467:     osg::Vec4 point2Screen = osg::Vec4(point2.x(), point2.y(), 0.0, 1.0);
	Line 467:     osg::Vec4 point2Screen = osg::Vec4(point2.x(), point2.y(), 0.0, 1.0);
	Line 479:     osg::Quat pitchRollQuat = osg::Quat(0.0, osg::Vec3d(1, 0, 0),
	Line 479:     osg::Quat pitchRollQuat = osg::Quat(0.0, osg::Vec3d(1, 0, 0),
	Line 479:     osg::Quat pitchRollQuat = osg::Quat(0.0, osg::Vec3d(1, 0, 0),
	Line 480:                                         0, osg::Vec3d(0, 1, 0),
	Line 481:                                         effectiveRoll * M_PI / 180.0, osg::Vec3d(0, 0, 1));
	Line 483:     osg::Vec4 point1World = inverseWindowMatrix * inverseProjectionMatrix * inverseViewMatrix * point1Screen;
	Line 484:     osg::Vec4 point2World = inverseWindowMatrix * inverseProjectionMatrix * inverseViewMatrix * point2Screen;
	Line 541:     osg::Vec4 screenPoints = osg::Vec4(point1Screen.x(), point1Screen.y(), point2Screen.x(), point2Screen.y());
	Line 541:     osg::Vec4 screenPoints = osg::Vec4(point1Screen.x(), point1Screen.y(), point2Screen.x(), point2Screen.y());
	Line 546: void UAVOverlay::drawText(osg::RenderInfo& ri, char* text, float horizOffset, float vertOffset, float altitude)
	Line 553: /*void UAVOverlay::drawWaypointIndicators(osg::RenderInfo& ri)
	Line 567:       mWaypointTexts[i].text->getOrCreateStateSet()->setDataVariance(osg::Object::DYNAMIC);
	Line 578:         mWaypointTexts[i].text->setColor(osg::Vec4(1, 0, 0, 1));
	Line 580:         mWaypointTexts[i].text->setColor(osg::Vec4(255/255.0, 75/255.0, 170/255.0, 1.0));
  D:\Development\psim\src\subview\UAVOverlay.h (22 hits)
	Line 18: class UAVOverlay : public osg::Geometry
	Line 23:     //  UAVOverlay(const UAVOverlay& UAVOverlay,const osg::CopyOp& copyop=osg::CopyOp::SHALLOW_COPY):
	Line 23:     //  UAVOverlay(const UAVOverlay& UAVOverlay,const osg::CopyOp& copyop=osg::CopyOp::SHALLOW_COPY):
	Line 24:     //osg::Geometry(UAVOverlay,copyop) {}
	Line 30:     virtual void drawImplementation(osg::RenderInfo& ri) const;
	Line 32:     virtual void addToOSG(osg::Group * root);
	Line 33:     virtual void addDrawable(osg::Geode * geode);
	Line 68:     osg::ref_ptr<osg::RefMatrix> sProjectionMatrix;
	Line 68:     osg::ref_ptr<osg::RefMatrix> sProjectionMatrix;
	Line 69:     osg::ref_ptr<osg::RefMatrix> sModelviewMatrix;
	Line 69:     osg::ref_ptr<osg::RefMatrix> sModelviewMatrix;
	Line 70:     osg::ref_ptr<osg::StateSet> stateSet;
	Line 70:     osg::ref_ptr<osg::StateSet> stateSet;
	Line 73:     void overlayInitialization(OverlayTexture* overlay, char* overlayLoc, osg::Vec3 rgb);
	Line 74:     void draw(osg::RenderInfo& ri);
	Line 78:     void drawHorizonLine(osg::RenderInfo& ri);
	Line 79:     void drawText(osg::RenderInfo& ri, char* text, float horizOfset, float vertOffset, float altitude);
	Line 80:     void drawWaypointIndicators(osg::RenderInfo& ri);
	Line 82:     osg::Vec4 pitchRollRotations(osg::Vec2 point1, osg::Vec2 point2, osg::RenderInfo& ri);
	Line 82:     osg::Vec4 pitchRollRotations(osg::Vec2 point1, osg::Vec2 point2, osg::RenderInfo& ri);
	Line 82:     osg::Vec4 pitchRollRotations(osg::Vec2 point1, osg::Vec2 point2, osg::RenderInfo& ri);
	Line 82:     osg::Vec4 pitchRollRotations(osg::Vec2 point1, osg::Vec2 point2, osg::RenderInfo& ri);
  D:\Development\psim\src\subview\UniformCallback.h (27 hits)
	Line 11: class UniformBoolUpdate : public osg::Uniform::Uniform::Callback
	Line 15:         virtual void operator()(osg::Uniform * uniform, osg::NodeVisitor * nv)
	Line 15:         virtual void operator()(osg::Uniform * uniform, osg::NodeVisitor * nv)
	Line 23: class UniformFloatUpdate : public osg::Uniform::Uniform::Callback
	Line 27:         virtual void operator()(osg::Uniform * uniform, osg::NodeVisitor * nv)
	Line 27:         virtual void operator()(osg::Uniform * uniform, osg::NodeVisitor * nv)
	Line 35: class UniformVec3fUpdate : public osg::Uniform::Uniform::Callback
	Line 38:         UniformVec3fUpdate(const std::function<osg::Vec3f()>& eval) : mEval(eval) {}
	Line 39:         virtual void operator()(osg::Uniform * uniform, osg::NodeVisitor * nv)
	Line 39:         virtual void operator()(osg::Uniform * uniform, osg::NodeVisitor * nv)
	Line 44:         std::function<osg::Vec3f()> mEval;
	Line 47: class UniformVec4fUpdate : public osg::Uniform::Uniform::Callback
	Line 50:         UniformVec4fUpdate(const std::function<osg::Vec4f()>& eval) : mEval(eval) {}
	Line 51:         virtual void operator()(osg::Uniform * uniform, osg::NodeVisitor * nv)
	Line 51:         virtual void operator()(osg::Uniform * uniform, osg::NodeVisitor * nv)
	Line 56:         std::function<osg::Vec4f()> mEval;
	Line 60: void addStaticUniform(osg::StateSet *stateSet, std::string name, osg::Uniform::Type uniformType, valueType value)
	Line 60: void addStaticUniform(osg::StateSet *stateSet, std::string name, osg::Uniform::Type uniformType, valueType value)
	Line 62:     osg::ref_ptr<osg::Uniform> uniform = new osg::Uniform(uniformType, name);
	Line 62:     osg::ref_ptr<osg::Uniform> uniform = new osg::Uniform(uniformType, name);
	Line 62:     osg::ref_ptr<osg::Uniform> uniform = new osg::Uniform(uniformType, name);
	Line 72: void addDynamicUniform(osg::StateSet *stateSet, std::string name, osg::Uniform::Type uniformType, valueType value,
	Line 72: void addDynamicUniform(osg::StateSet *stateSet, std::string name, osg::Uniform::Type uniformType, valueType value,
	Line 73:                        osg::Uniform::Uniform::Callback *callback)
	Line 75:     osg::ref_ptr<osg::Uniform> uniform = new osg::Uniform(uniformType, name);
	Line 75:     osg::ref_ptr<osg::Uniform> uniform = new osg::Uniform(uniformType, name);
	Line 75:     osg::ref_ptr<osg::Uniform> uniform = new osg::Uniform(uniformType, name);
  D:\Development\psim\src\subview\UpdateCubemapCamera.cpp (44 hits)
	Line 25: extern osg::ref_ptr<osg::Camera> pickCamera;
	Line 25: extern osg::ref_ptr<osg::Camera> pickCamera;
	Line 30:         osg::ref_ptr<osg::Camera> nearCamera,
	Line 30:         osg::ref_ptr<osg::Camera> nearCamera,
	Line 31:         osg::ref_ptr<osg::Camera> mainCamera) :
	Line 31:         osg::ref_ptr<osg::Camera> mainCamera) :
	Line 44: void UpdateCubemapCamera::operator()(osg::Node* node, osg::NodeVisitor* nv)
	Line 44: void UpdateCubemapCamera::operator()(osg::Node* node, osg::NodeVisitor* nv)
	Line 73:     osg::Vec3f eye, center, dir, up;
	Line 116:     //	osg::Vec3 position(eye[0],eye[1],-eye[2]);
	Line 118:     osg::Vec3 position(center[0], center[1], cubemap_height);
	Line 120:     typedef std::pair<osg::Vec3, osg::Vec3> ImageData;
	Line 120:     typedef std::pair<osg::Vec3, osg::Vec3> ImageData;
	Line 122:         ImageData(osg::Vec3(1, 0, 0), osg::Vec3(0, -1, 0)), // +X   // right       
	Line 122:         ImageData(osg::Vec3(1, 0, 0), osg::Vec3(0, -1, 0)), // +X   // right       
	Line 123:         ImageData(osg::Vec3(-1, 0, 0), osg::Vec3(0, -1, 0)), // -X  // left
	Line 123:         ImageData(osg::Vec3(-1, 0, 0), osg::Vec3(0, -1, 0)), // -X  // left
	Line 124:         ImageData(osg::Vec3(0, 1, 0), osg::Vec3(0, 0, 1)), // +Y // front 
	Line 124:         ImageData(osg::Vec3(0, 1, 0), osg::Vec3(0, 0, 1)), // +Y // front 
	Line 125:         ImageData(osg::Vec3(0, -1, 0), osg::Vec3(0, 0, -1)), // -Y // back
	Line 125:         ImageData(osg::Vec3(0, -1, 0), osg::Vec3(0, 0, -1)), // -Y // back
	Line 126:         ImageData(osg::Vec3(0, 0, 1), osg::Vec3(0, -1, 0)), // +Z   // top
	Line 126:         ImageData(osg::Vec3(0, 0, 1), osg::Vec3(0, -1, 0)), // +Z   // top
	Line 127:         ImageData(osg::Vec3(0, 0, -1), osg::Vec3(0, -1, 0)) // -Z   // bottom			                
	Line 127:         ImageData(osg::Vec3(0, 0, -1), osg::Vec3(0, -1, 0)) // -Z   // bottom			                
	Line 128:         /*		ImageData( osg::Vec3(1,  0,  0), osg::Vec3( 0, 1,  0) ), // +X   // right       
	Line 128:         /*		ImageData( osg::Vec3(1,  0,  0), osg::Vec3( 0, 1,  0) ), // +X   // right       
	Line 129:          ImageData( osg::Vec3(-1,  0,  0), osg::Vec3( 0, 1,  0) ), // -X  // left
	Line 129:          ImageData( osg::Vec3(-1,  0,  0), osg::Vec3( 0, 1,  0) ), // -X  // left
	Line 130:          ImageData( osg::Vec3( 0,  1,  0), osg::Vec3( 1,  0,  0) ), // +Y // front 
	Line 130:          ImageData( osg::Vec3( 0,  1,  0), osg::Vec3( 1,  0,  0) ), // +Y // front 
	Line 131:          ImageData( osg::Vec3( 0, -1,  0), osg::Vec3( 1,  0, 0) ), // -Y // back
	Line 131:          ImageData( osg::Vec3( 0, -1,  0), osg::Vec3( 1,  0, 0) ), // -Y // back
	Line 132:          ImageData( osg::Vec3( 0,  0,  1), osg::Vec3( 0, 1,  0) ), // +Z   // top
	Line 132:          ImageData( osg::Vec3( 0,  0,  1), osg::Vec3( 0, 1,  0) ), // +Z   // top
	Line 133:          ImageData( osg::Vec3( 0,  0, -1), osg::Vec3( 0, 1,  0) )  // -Z   // bottom
	Line 133:          ImageData( osg::Vec3( 0,  0, -1), osg::Vec3( 0, 1,  0) )  // -Z   // bottom
	Line 143:         osg::Matrix localOffset;
	Line 145:         osg::Matrix viewMatrix = localOffset; //_mainCamer-a->getViewMatrix()*localOffset;
	Line 146:         _Cameras[i]->setReferenceFrame(osg::Camera::ABSOLUTE_RF);
	Line 154:         osg::Matrix localOffset;
	Line 156:         _CamerasPP[i]->setReferenceFrame(osg::Camera::ABSOLUTE_RF);
	Line 161:     osg::Matrix viewMatrix = _mainCamera->getViewMatrix();
	Line 163:     _nearCamera->setReferenceFrame(osg::Camera::ABSOLUTE_RF);
  D:\Development\psim\src\subview\UpdateCubemapCamera.h (15 hits)
	Line 19: class UpdateCubemapCamera : public osg::NodeCallback
	Line 22:     typedef std::vector< osg::ref_ptr<osg::Switch> > CameraSwitchList;
	Line 22:     typedef std::vector< osg::ref_ptr<osg::Switch> > CameraSwitchList;
	Line 23:     typedef std::vector< osg::ref_ptr<osg::Camera> > CameraList;
	Line 23:     typedef std::vector< osg::ref_ptr<osg::Camera> > CameraList;
	Line 28:             osg::ref_ptr<osg::Camera> nearCamera,
	Line 28:             osg::ref_ptr<osg::Camera> nearCamera,
	Line 29:             osg::ref_ptr<osg::Camera> mainCamera);
	Line 29:             osg::ref_ptr<osg::Camera> mainCamera);
	Line 31:     virtual void operator()(osg::Node* node, osg::NodeVisitor* nv);
	Line 31:     virtual void operator()(osg::Node* node, osg::NodeVisitor* nv);
	Line 39:     osg::ref_ptr<osg::Camera> _nearCamera;
	Line 39:     osg::ref_ptr<osg::Camera> _nearCamera;
	Line 40:     osg::ref_ptr<osg::Camera> _mainCamera;
	Line 40:     osg::ref_ptr<osg::Camera> _mainCamera;
  D:\Development\psim\src\subview\Vehicle.cpp (132 hits)
	Line 104: sternLightPos(osg::Vec3(0., 0., 0.)),
	Line 105: sternLightDir(osg::Vec3(0., 0., 0.)),
	Line 118: modelOrigin(osg::Vec3(0.0, 0.0, 0.0)),
	Line 125: mKnucklePos(osg::Vec3(0.0, 0.0, 0.0)),
	Line 138:     xform = new osg::MatrixTransform;
	Line 143:     xformBoundingBox = new osg::MatrixTransform;
	Line 147:     xformMat = new osg::Matrixf;
	Line 269:     osg::Vec2d movementVector(newPosition[0], newPosition[1]);
	Line 275:     osg::Vec3 headingVector3 = osg::Matrixf::rotate(osg::DegreesToRadians(contactHPR[0]), osg::Vec3(0., 0., 1.)).preMult(osg::Vec3(1.f, 0.f, 0.f));
	Line 275:     osg::Vec3 headingVector3 = osg::Matrixf::rotate(osg::DegreesToRadians(contactHPR[0]), osg::Vec3(0., 0., 1.)).preMult(osg::Vec3(1.f, 0.f, 0.f));
	Line 275:     osg::Vec3 headingVector3 = osg::Matrixf::rotate(osg::DegreesToRadians(contactHPR[0]), osg::Vec3(0., 0., 1.)).preMult(osg::Vec3(1.f, 0.f, 0.f));
	Line 275:     osg::Vec3 headingVector3 = osg::Matrixf::rotate(osg::DegreesToRadians(contactHPR[0]), osg::Vec3(0., 0., 1.)).preMult(osg::Vec3(1.f, 0.f, 0.f));
	Line 275:     osg::Vec3 headingVector3 = osg::Matrixf::rotate(osg::DegreesToRadians(contactHPR[0]), osg::Vec3(0., 0., 1.)).preMult(osg::Vec3(1.f, 0.f, 0.f));
	Line 276:     osg::Vec2 headingVector2(headingVector3.x(), headingVector3.y());
	Line 341:             osg::Node* node = xform->getChild(i);
	Line 343:                 mLightGeometry = (osg::Geometry*)((osg::Geode*)node)->getDrawable(0);
	Line 343:                 mLightGeometry = (osg::Geometry*)((osg::Geode*)node)->getDrawable(0);
	Line 456: void Vehicle::initHullNumber(osg::Group *hullGrp)
	Line 463:         std::vector<osg::Vec2Array*> curTexCoords;
	Line 464:         osg::ref_ptr<osg::Group> sideGrp = (osg::Group *) mHullGrp->getChild(numberSet);
	Line 464:         osg::ref_ptr<osg::Group> sideGrp = (osg::Group *) mHullGrp->getChild(numberSet);
	Line 464:         osg::ref_ptr<osg::Group> sideGrp = (osg::Group *) mHullGrp->getChild(numberSet);
	Line 469:             osg::ref_ptr<osg::Geode> origQuad = dynamic_cast<osg::Geode *> (sideGrp->getChild(curQuad));
	Line 469:             osg::ref_ptr<osg::Geode> origQuad = dynamic_cast<osg::Geode *> (sideGrp->getChild(curQuad));
	Line 469:             osg::ref_ptr<osg::Geode> origQuad = dynamic_cast<osg::Geode *> (sideGrp->getChild(curQuad));
	Line 470:             osg::ref_ptr<osg::Geometry> origGeom = dynamic_cast<osg::Geometry *> (origQuad->getDrawable(0));
	Line 470:             osg::ref_ptr<osg::Geometry> origGeom = dynamic_cast<osg::Geometry *> (origQuad->getDrawable(0));
	Line 470:             osg::ref_ptr<osg::Geometry> origGeom = dynamic_cast<osg::Geometry *> (origQuad->getDrawable(0));
	Line 471:             curTexCoords.push_back(dynamic_cast<osg::Vec2Array *> (origGeom->getTexCoordArray(0)));
	Line 474:             osg::ref_ptr<osg::Geode> newQuad = (osg::Geode *) origQuad->clone(osg::CopyOp::DEEP_COPY_ALL);
	Line 474:             osg::ref_ptr<osg::Geode> newQuad = (osg::Geode *) origQuad->clone(osg::CopyOp::DEEP_COPY_ALL);
	Line 474:             osg::ref_ptr<osg::Geode> newQuad = (osg::Geode *) origQuad->clone(osg::CopyOp::DEEP_COPY_ALL);
	Line 474:             osg::ref_ptr<osg::Geode> newQuad = (osg::Geode *) origQuad->clone(osg::CopyOp::DEEP_COPY_ALL);
	Line 508:         osg::ref_ptr<osg::Group> sideGrp = (osg::Group *) mHullGrp->getChild(numberSet);
	Line 508:         osg::ref_ptr<osg::Group> sideGrp = (osg::Group *) mHullGrp->getChild(numberSet);
	Line 508:         osg::ref_ptr<osg::Group> sideGrp = (osg::Group *) mHullGrp->getChild(numberSet);
	Line 565:             osg::ref_ptr<osg::Geode> quad = dynamic_cast<osg::Geode *> (sideGrp->getChild(curQuad));
	Line 565:             osg::ref_ptr<osg::Geode> quad = dynamic_cast<osg::Geode *> (sideGrp->getChild(curQuad));
	Line 565:             osg::ref_ptr<osg::Geode> quad = dynamic_cast<osg::Geode *> (sideGrp->getChild(curQuad));
	Line 566:             osg::ref_ptr<osg::Geometry> geom = dynamic_cast<osg::Geometry *> (quad->getDrawable(0));
	Line 566:             osg::ref_ptr<osg::Geometry> geom = dynamic_cast<osg::Geometry *> (quad->getDrawable(0));
	Line 566:             osg::ref_ptr<osg::Geometry> geom = dynamic_cast<osg::Geometry *> (quad->getDrawable(0));
	Line 567:             osg::Vec2Array* texCoords = dynamic_cast<osg::Vec2Array *> (geom->getTexCoordArray(0));
	Line 567:             osg::Vec2Array* texCoords = dynamic_cast<osg::Vec2Array *> (geom->getTexCoordArray(0));
	Line 570:             osg::Geometry::PrimitiveSetList list = geom->getPrimitiveSetList();
	Line 572:             if (list[0]->getMode() == osg::PrimitiveSet::TRIANGLES) numCoords = int(numCoords / 3) + 2; //if it is just triangles, use this calculation
	Line 639: void Vehicle::setHorizontalLaunchPoint(osg::Vec3f launchH)
	Line 646: void Vehicle::setVerticalLaunchPoint(osg::Vec3f launchV)
	Line 694: void Vehicle::addVlsCellLaunchPt(std::string name, osg::Vec3 point)
	Line 696:     vlsCellLaunchPts.insert(std::pair<std::string, osg::Vec3>(name, point));
	Line 706: void Vehicle::addVlsVentLaunchPt(std::string name, osg::Vec3 point)
	Line 708:     vlsVentLaunchPts.insert(std::pair<std::string, osg::Vec3>(name, point));
	Line 718: //void Vehicle::setGWSSmokePt(std::string whichGun, osg::Vec3 point)
	Line 799:             osg::Vec3d launchPt = getVlsCellLaunchPt(launcherSet, moduleNumber, cellNumber);
	Line 857: osg::Vec3 Vehicle::getVlsCellLaunchPt(int launcherSet, int moduleNumber, int cellNumber)
	Line 870:     for (std::map<std::string, osg::Vec3 >::iterator pointIter = vlsCellLaunchPts.begin();
	Line 886:     return osg::Vec3f(0, 0, 0);
	Line 896: osg::Vec3 Vehicle::getVlsVentLaunchPt(int launcherSet, int moduleNumber)
	Line 909:     std::map<std::string, osg::Vec3f>::iterator pointIter = vlsVentLaunchPts.begin();
	Line 926:     return osg::Vec3f(0, 0, 0);
	Line 935: osg::Vec3 Vehicle::getGWSSmokePt(std::string whichGun)
	Line 990:     explode(osg::Vec3(0, 0, 0));
	Line 996:  * Input: osg::Vec3f - X/Y/Z position relative to the vehicle
	Line 999: void Vehicle::explode(osg::Vec3f offset)
	Line 1006:     params.setGeomDimensions(osg::Vec2(175, 175));
	Line 1012:     params.setOrientation(osg::Vec3(0, 0, 1));
	Line 1027:     osg::MatrixTransform * loadedModelTransform = (osg::MatrixTransform *)(xform.get());
	Line 1027:     osg::MatrixTransform * loadedModelTransform = (osg::MatrixTransform *)(xform.get());
	Line 1028:     osg::Vec3 pos = contactLoc;
	Line 1029:     osg::Vec3 hpr = contactHPR;
	Line 1033:         loadedModelTransform->setMatrix(osg::Matrix::rotate(osg::inDegrees(0.), 0.0f, 0.0f, 1.0f) *
	Line 1033:         loadedModelTransform->setMatrix(osg::Matrix::rotate(osg::inDegrees(0.), 0.0f, 0.0f, 1.0f) *
	Line 1034:                 osg::Matrix::translate(pos[0], pos[1], pos[2])
	Line 1040:         loadedModelTransform->setMatrix(osg::Matrix::scale(scale, scale, scale) *
	Line 1041:                 osg::Matrix::rotate(osg::inDegrees(hpr[2]), 1.0f, 0.0f, 0.0f) *
	Line 1041:                 osg::Matrix::rotate(osg::inDegrees(hpr[2]), 1.0f, 0.0f, 0.0f) *
	Line 1042:                 osg::Matrix::rotate(osg::inDegrees(hpr[1]), 0.0f, 1.0f, 0.0f) *
	Line 1042:                 osg::Matrix::rotate(osg::inDegrees(hpr[1]), 0.0f, 1.0f, 0.0f) *
	Line 1043:                 osg::Matrix::rotate(osg::inDegrees(hpr[0]), 0.0f, 0.0f, 1.0f) *
	Line 1043:                 osg::Matrix::rotate(osg::inDegrees(hpr[0]), 0.0f, 0.0f, 1.0f) *
	Line 1044:                 osg::Matrix::translate(pos[0], pos[1], pos[2])
	Line 1051:     if (xformBoundingBox) ((osg::MatrixTransform *)(xformBoundingBox.get()))->setMatrix(*(xformMat));
	Line 1061:             lightPos_1 = new osg::Uniform("lightPos_1", osg::Vec3(0.f, 0.f, 0.f));
	Line 1061:             lightPos_1 = new osg::Uniform("lightPos_1", osg::Vec3(0.f, 0.f, 0.f));
	Line 1067:             lightColor_1 = new osg::Uniform("lightColor_1", osg::Vec3(0.f, 0.f, 0.f));
	Line 1067:             lightColor_1 = new osg::Uniform("lightColor_1", osg::Vec3(0.f, 0.f, 0.f));
	Line 1073:             lightPos_2 = new osg::Uniform("lightPos_2", osg::Vec3(0.f, 0.f, 0.f));
	Line 1073:             lightPos_2 = new osg::Uniform("lightPos_2", osg::Vec3(0.f, 0.f, 0.f));
	Line 1079:             lightColor_2 = new osg::Uniform("lightColor_2", osg::Vec3(0.f, 0.f, 0.f));
	Line 1079:             lightColor_2 = new osg::Uniform("lightColor_2", osg::Vec3(0.f, 0.f, 0.f));
	Line 1247: osg::Vec3f Vehicle::getActiveMastLoc()
	Line 1265:                 osg::Vec3f curMastLoc = curMastXform->getActiveMastLoc();
	Line 1287:     osg::Vec3f activeMastLoc = osg::Vec3f(farthestScopeDist, averageScopeXLoc, 0.f);
	Line 1287:     osg::Vec3f activeMastLoc = osg::Vec3f(farthestScopeDist, averageScopeXLoc, 0.f);
	Line 1534: void Vehicle::setLightStateSet(osg::StateSet* ss)
	Line 1539: void Vehicle::setLightGeometry(osg::Geometry* geo)
	Line 1544: void Vehicle::setLightPos_1(osg::Vec3 val)
	Line 1549: void Vehicle::setLightColor_1(osg::Vec3 val)
	Line 1554: void Vehicle::setLightPos_2(osg::Vec3 val)
	Line 1559: void Vehicle::setLightColor_2(osg::Vec3 val)
	Line 1564: void Vehicle::setSternLightPos(osg::Vec3 val)
	Line 1569: void Vehicle::setSternLightDir(osg::Vec3 val)
	Line 1574: void Vehicle::setSailTopPt(osg::Vec3f topPivotPt)
	Line 1580: void Vehicle::setSailBasePt(osg::Vec3f basePivotPt)
	Line 1586: void Vehicle::setBowWakePt(osg::Vec3f wakePivotPt)
	Line 1591: void Vehicle::setBowWakeRightPt(osg::Vec3f wakeRightPivotPt)
	Line 1596: void Vehicle::setBowWakeLeftPt(osg::Vec3f wakeLeftPivotPt)
	Line 1606: void Vehicle::setEyepoint(int scopeNum, osg::Vec3f point)
	Line 1611: void Vehicle::setEdgeBuoyTranslate(const osg::Vec3f& translate)
	Line 1621: void Vehicle::setRudderPosition(osg::Vec3f position)
	Line 1643: void Vehicle::setKnucklePos(osg::Vec3f knucklePos)
	Line 1650: void Vehicle::setWindscreenDrawBox(osg::Group * windscreenDrawBox)
	Line 1655: void Vehicle::setWindscreenDrawBoxBB(osg::BoundingBox windscreenDrawBoxBB)
	Line 1700: osg::Vec3 Vehicle::getMin()
	Line 1705: osg::Vec3 Vehicle::getMax()
	Line 1869: osg::Vec3f Vehicle::getModelOrigin()
	Line 1919: osg::Vec3d Vehicle::getContactLoc()
	Line 1924: osg::Vec3f Vehicle::getContactHPR()
	Line 1969: osg::Vec2d Vehicle::getMovementVector()
	Line 1984: osg::Vec3 Vehicle::getSternLightPos()
	Line 1989: osg::Vec3 Vehicle::getSternLightDir()
	Line 1994: osg::Vec3f Vehicle::getHorizontalLaunchPoint()
	Line 1999: osg::Vec3f Vehicle::getVerticalLaunchPoint()
	Line 2004: osg::Vec3f Vehicle::getBowWakePt()
	Line 2009: osg::Vec3f Vehicle::getBowWakeRightPt()
	Line 2014: osg::Vec3f Vehicle::getBowWakeLeftPt()
	Line 2019: osg::Vec3f Vehicle::getSailTopPt()
	Line 2024: osg::Vec3f Vehicle::getSailBasePt()
	Line 2049: osg::Vec3f Vehicle::getRudderPosition()
	Line 2071: osg::Vec3f Vehicle::getKnucklePos()
	Line 2078: osg::Group * Vehicle::getWindscreenDrawBox()
	Line 2083: osg::BoundingBox Vehicle::getWindscreenDrawBoxBB()
  D:\Development\psim\src\subview\Vehicle.h (99 hits)
	Line 62:     virtual void initHullNumber(osg::Group *hullGrp);
	Line 77:     void addVlsCellLaunchPt(std::string name, osg::Vec3 point);
	Line 78:     void addVlsVentLaunchPt(std::string name, osg::Vec3 point);
	Line 79:     //    void setGWSSmokePt(std::string whichGun, osg::Vec3 point);
	Line 83:     void setHorizontalLaunchPoint(osg::Vec3f launchH);
	Line 84:     void setVerticalLaunchPoint(osg::Vec3f launchV);
	Line 125:     void setLightStateSet(osg::StateSet* ss);
	Line 126:     void setLightGeometry(osg::Geometry* geo);
	Line 127:     void setLightPos_1(osg::Vec3 val);
	Line 128:     void setLightColor_1(osg::Vec3 val);
	Line 129:     void setLightPos_2(osg::Vec3 val);
	Line 130:     void setLightColor_2(osg::Vec3 val);
	Line 131:     void setSternLightPos(osg::Vec3 val);
	Line 132:     void setSternLightDir(osg::Vec3 val);
	Line 133:     void setSailTopPt(osg::Vec3f topPivotPt);
	Line 134:     void setSailBasePt(osg::Vec3f basePivotPt);
	Line 135:     void setBowWakePt(osg::Vec3f wakePivotPt);
	Line 136:     void setBowWakeRightPt(osg::Vec3f wakeRightPivotPt);
	Line 137:     void setBowWakeLeftPt(osg::Vec3f wakeLeftPivotPt);
	Line 139:     void setEyepoint(int scopeNum, osg::Vec3f point);
	Line 140:     void setEdgeBuoyTranslate(const osg::Vec3f& translate);
	Line 142:     void setRudderPosition(osg::Vec3f position);
	Line 148:     void setKnucklePos(osg::Vec3f knucklePos);
	Line 151:     void setWindscreenDrawBox(osg::Group * windscreenDrawBox);
	Line 152:     void setWindscreenDrawBoxBB(osg::BoundingBox windscreenDrawBoxBB);
	Line 163:     void explode(osg::Vec3f offset);
	Line 176:     osg::Vec3 getMin();
	Line 177:     osg::Vec3 getMax();
	Line 212:     osg::Vec3f getModelOrigin();
	Line 222:     osg::Vec3d getContactLoc();
	Line 223:     osg::Vec3f getContactHPR();
	Line 232:     osg::Vec2d getMovementVector();
	Line 235:     osg::Vec3 getSternLightPos();
	Line 236:     osg::Vec3 getSternLightDir();
	Line 237:     osg::Vec3f getHorizontalLaunchPoint();
	Line 238:     osg::Vec3f getVerticalLaunchPoint();
	Line 239:     osg::Vec3f getBowWakePt();
	Line 240:     osg::Vec3f getBowWakeRightPt();
	Line 241:     osg::Vec3f getBowWakeLeftPt();
	Line 242:     osg::Vec3f getSailTopPt();
	Line 243:     osg::Vec3f getSailBasePt();
	Line 248:     osg::Vec3f getRudderPosition();
	Line 254:     osg::Vec3f getKnucklePos();
	Line 257:     osg::Group * getWindscreenDrawBox();
	Line 258:     osg::BoundingBox getWindscreenDrawBoxBB();
	Line 269:     osg::Vec3f getActiveMastLoc();
	Line 273:     osg::Vec3 getVlsCellLaunchPt(int launcherSet, int moduleNumber, int cellNumber);
	Line 274:     osg::Vec3 getVlsVentLaunchPt(int launcherSet, int moduleNumber);
	Line 275:     osg::Vec3 getGWSSmokePt(std::string whichGun);
	Line 286:     osg::ref_ptr<osg::Group> xform;
	Line 286:     osg::ref_ptr<osg::Group> xform;
	Line 288:     osg::ref_ptr<osg::Group> xformBoundingBox;
	Line 288:     osg::ref_ptr<osg::Group> xformBoundingBox;
	Line 290:     osg::ref_ptr<osg::Node> nodeInstance;
	Line 290:     osg::ref_ptr<osg::Node> nodeInstance;
	Line 294:     osg::Vec3 mCameraWorldPos;
	Line 315:     osg::Matrixf* xformMat;
	Line 316:     osg::ref_ptr<osg::Group> mHullGrp;
	Line 316:     osg::ref_ptr<osg::Group> mHullGrp;
	Line 317:     std::vector< std::vector<osg::Vec2Array*> > origTexCoords;
	Line 336:     osg::Vec3 modelOrigin;
	Line 352:     osg::Vec3d contactLoc;
	Line 353:     osg::Vec3f contactHPR;
	Line 354:     osg::Vec3f mEdgeBuoyTranslate;
	Line 370:     osg::Vec2d moveVec;
	Line 371:     osg::Vec2d lastPosition;
	Line 376:     osg::ref_ptr<LightSystemUpdate> mLightSystemUpdate;
	Line 377:     osg::ref_ptr<LightSystemStateSetUpdate> mLightSystemStateSetUpdate;
	Line 378:     osg::ref_ptr<osg::StateSet> mLightStateSet;
	Line 378:     osg::ref_ptr<osg::StateSet> mLightStateSet;
	Line 379:     osg::ref_ptr<osg::Geometry> mLightGeometry;
	Line 379:     osg::ref_ptr<osg::Geometry> mLightGeometry;
	Line 380:     osg::ref_ptr<osg::Uniform> lightPos_1;
	Line 380:     osg::ref_ptr<osg::Uniform> lightPos_1;
	Line 381:     osg::ref_ptr<osg::Uniform> lightColor_1;
	Line 381:     osg::ref_ptr<osg::Uniform> lightColor_1;
	Line 382:     osg::ref_ptr<osg::Uniform> lightPos_2;
	Line 382:     osg::ref_ptr<osg::Uniform> lightPos_2;
	Line 383:     osg::ref_ptr<osg::Uniform> lightColor_2;
	Line 383:     osg::ref_ptr<osg::Uniform> lightColor_2;
	Line 384:     osg::Vec3 sternLightPos;
	Line 385:     osg::Vec3 sternLightDir;
	Line 388:     osg::Vec3 horizontalLaunchPt;
	Line 389:     osg::Vec3 verticalLaunchPt;
	Line 390:     std::map<std::string, osg::Vec3f> vlsCellLaunchPts;
	Line 391:     std::map<std::string, osg::Vec3f> vlsVentLaunchPts;
	Line 392:     osg::Vec3f gwsFrontSmokePt;
	Line 393:     osg::Vec3f gwsRearSmokePt;
	Line 396:     osg::Vec3 bowWakePt;
	Line 397:     osg::Vec3 bowWakeRightPt;
	Line 398:     osg::Vec3 bowWakeLeftPt;
	Line 399:     osg::Vec3 sailTopPt;
	Line 400:     osg::Vec3 sailBasePt;
	Line 401:     std::vector <osg::Vec3f> mScopeEyepoints;
	Line 402:     osg::Vec3f mRudderPosition;
	Line 405:     osg::Vec3f mKnucklePos;
	Line 408:     osg::ref_ptr<osg::Group> mWindscreenDrawBox; //draw box for wind screen values
	Line 408:     osg::ref_ptr<osg::Group> mWindscreenDrawBox; //draw box for wind screen values
	Line 409:     osg::BoundingBox mWindscreenDrawBoxBB;
  D:\Development\psim\src\subview\VehicleVisibilityUpdate.cpp (4 hits)
	Line 22: void VehicleVisibilityUpdate::operator()(osg::Node * node, osg::NodeVisitor * nv)
	Line 22: void VehicleVisibilityUpdate::operator()(osg::Node * node, osg::NodeVisitor * nv)
	Line 24:     osg::Switch * visibilitySwitch = dynamic_cast<osg::Switch *> (node);
	Line 24:     osg::Switch * visibilitySwitch = dynamic_cast<osg::Switch *> (node);
  D:\Development\psim\src\subview\VehicleVisibilityUpdate.h (3 hits)
	Line 19: class VehicleVisibilityUpdate : public osg::NodeCallback
	Line 27:     virtual void operator()(osg::Node * node, osg::NodeVisitor * nv);
	Line 27:     virtual void operator()(osg::Node * node, osg::NodeVisitor * nv);
  D:\Development\psim\src\subview\VesubHud.cpp (2 hits)
	Line 51: void VesubHud::drawImplementation(osg::RenderInfo& ri) const
	Line 57: void VesubHud::draw(osg::RenderInfo& ri)
  D:\Development\psim\src\subview\VesubHud.h (2 hits)
	Line 14:     virtual void drawImplementation(osg::RenderInfo& ri) const;
	Line 17:     void draw(osg::RenderInfo& ri);
  D:\Development\psim\src\subview\VesubPickOp.cpp (4 hits)
	Line 23: void VesubPickOp::operator()(osg::Object* obj)
	Line 30:         osg::Node *pNode = new osg::Node();
	Line 30:         osg::Node *pNode = new osg::Node();
	Line 32:         osg::ref_ptr<PickNodeCallback> pickNode = new PickNodeCallback(true);
  D:\Development\psim\src\subview\VesubPickOp.h (2 hits)
	Line 13: class VesubPickOp : public osg::Operation
	Line 19:     void operator()(osg::Object* obj);
  D:\Development\psim\src\subview\VideoShmWriter.cpp (10 hits)
	Line 27: VideoShmWriter::VideoShmWriter(std::string _shm_key, int _width, int _height, osg::Image* imageBuffer, osg::Texture* _fbo_tex) :
	Line 27: VideoShmWriter::VideoShmWriter(std::string _shm_key, int _width, int _height, osg::Image* imageBuffer, osg::Texture* _fbo_tex) :
	Line 492:             osg::ref_ptr<osg::Image> newImage = new osg::Image();
	Line 492:             osg::ref_ptr<osg::Image> newImage = new osg::Image();
	Line 492:             osg::ref_ptr<osg::Image> newImage = new osg::Image();
	Line 493:             newImage->setImage(1280, 1024, 1, GL_RGB, GL_RGB, GL_UNSIGNED_BYTE, data, osg::Image::NO_DELETE);
	Line 530:                 osg::ref_ptr<osg::Image> newImage = new osg::Image();
	Line 530:                 osg::ref_ptr<osg::Image> newImage = new osg::Image();
	Line 530:                 osg::ref_ptr<osg::Image> newImage = new osg::Image();
	Line 531:                 newImage->setImage(1280, 1024, 1, GL_RGB, GL_RGB, GL_UNSIGNED_BYTE, data, osg::Image::NO_DELETE);
  D:\Development\psim\src\subview\VideoShmWriter.h (5 hits)
	Line 25:     VideoShmWriter(std::string _shm_key, int _width, int _height, osg::Image* imageBuffer = NULL, osg::Texture* _fbo_tex = NULL);
	Line 25:     VideoShmWriter(std::string _shm_key, int _width, int _height, osg::Image* imageBuffer = NULL, osg::Texture* _fbo_tex = NULL);
	Line 103:     osg::Image* mImageBuffer;
	Line 104:     osg::ref_ptr<osg::Texture> fboTex;
	Line 104:     osg::ref_ptr<osg::Texture> fboTex;
  D:\Development\psim\src\subview\ViewSpec.cpp (40 hits)
	Line 234:     for (ii = 0; ii < 4; ++ii) mBase[ii] = osg::Quat(mRotXYZ[0] * M_PI / 180, osg::X_AXIS, 0.0, osg::Y_AXIS, 0.0, osg::Z_AXIS) * mBase[ii];
	Line 234:     for (ii = 0; ii < 4; ++ii) mBase[ii] = osg::Quat(mRotXYZ[0] * M_PI / 180, osg::X_AXIS, 0.0, osg::Y_AXIS, 0.0, osg::Z_AXIS) * mBase[ii];
	Line 234:     for (ii = 0; ii < 4; ++ii) mBase[ii] = osg::Quat(mRotXYZ[0] * M_PI / 180, osg::X_AXIS, 0.0, osg::Y_AXIS, 0.0, osg::Z_AXIS) * mBase[ii];
	Line 234:     for (ii = 0; ii < 4; ++ii) mBase[ii] = osg::Quat(mRotXYZ[0] * M_PI / 180, osg::X_AXIS, 0.0, osg::Y_AXIS, 0.0, osg::Z_AXIS) * mBase[ii];
	Line 235:     for (ii = 0; ii < 4; ++ii) mBase[ii] = osg::Quat(0.0, osg::X_AXIS, mRotXYZ[1] * M_PI / 180, osg::Y_AXIS, 0.0, osg::Z_AXIS) * mBase[ii];
	Line 235:     for (ii = 0; ii < 4; ++ii) mBase[ii] = osg::Quat(0.0, osg::X_AXIS, mRotXYZ[1] * M_PI / 180, osg::Y_AXIS, 0.0, osg::Z_AXIS) * mBase[ii];
	Line 235:     for (ii = 0; ii < 4; ++ii) mBase[ii] = osg::Quat(0.0, osg::X_AXIS, mRotXYZ[1] * M_PI / 180, osg::Y_AXIS, 0.0, osg::Z_AXIS) * mBase[ii];
	Line 235:     for (ii = 0; ii < 4; ++ii) mBase[ii] = osg::Quat(0.0, osg::X_AXIS, mRotXYZ[1] * M_PI / 180, osg::Y_AXIS, 0.0, osg::Z_AXIS) * mBase[ii];
	Line 238:         mBase[ii] = osg::Quat(0.0, osg::X_AXIS, 0.0, osg::Y_AXIS, mRotXYZ[2] * M_PI / 180, osg::Z_AXIS) * mBase[ii];
	Line 238:         mBase[ii] = osg::Quat(0.0, osg::X_AXIS, 0.0, osg::Y_AXIS, mRotXYZ[2] * M_PI / 180, osg::Z_AXIS) * mBase[ii];
	Line 238:         mBase[ii] = osg::Quat(0.0, osg::X_AXIS, 0.0, osg::Y_AXIS, mRotXYZ[2] * M_PI / 180, osg::Z_AXIS) * mBase[ii];
	Line 238:         mBase[ii] = osg::Quat(0.0, osg::X_AXIS, 0.0, osg::Y_AXIS, mRotXYZ[2] * M_PI / 180, osg::Z_AXIS) * mBase[ii];
	Line 256:     for (ii = 0; ii < 6; ++ii) mPlanes[ii].ABC = osg::Quat(mRotXYZ[0] * M_PI / 180, osg::X_AXIS, 0.0, osg::Y_AXIS, 0.0, osg::Z_AXIS) * mPlanes[ii].ABC;
	Line 256:     for (ii = 0; ii < 6; ++ii) mPlanes[ii].ABC = osg::Quat(mRotXYZ[0] * M_PI / 180, osg::X_AXIS, 0.0, osg::Y_AXIS, 0.0, osg::Z_AXIS) * mPlanes[ii].ABC;
	Line 256:     for (ii = 0; ii < 6; ++ii) mPlanes[ii].ABC = osg::Quat(mRotXYZ[0] * M_PI / 180, osg::X_AXIS, 0.0, osg::Y_AXIS, 0.0, osg::Z_AXIS) * mPlanes[ii].ABC;
	Line 256:     for (ii = 0; ii < 6; ++ii) mPlanes[ii].ABC = osg::Quat(mRotXYZ[0] * M_PI / 180, osg::X_AXIS, 0.0, osg::Y_AXIS, 0.0, osg::Z_AXIS) * mPlanes[ii].ABC;
	Line 257:     for (ii = 0; ii < 6; ++ii) mPlanes[ii].ABC = osg::Quat(0.0, osg::X_AXIS, mRotXYZ[1] * M_PI / 180, osg::Y_AXIS, 0.0, osg::Z_AXIS) * mPlanes[ii].ABC;
	Line 257:     for (ii = 0; ii < 6; ++ii) mPlanes[ii].ABC = osg::Quat(0.0, osg::X_AXIS, mRotXYZ[1] * M_PI / 180, osg::Y_AXIS, 0.0, osg::Z_AXIS) * mPlanes[ii].ABC;
	Line 257:     for (ii = 0; ii < 6; ++ii) mPlanes[ii].ABC = osg::Quat(0.0, osg::X_AXIS, mRotXYZ[1] * M_PI / 180, osg::Y_AXIS, 0.0, osg::Z_AXIS) * mPlanes[ii].ABC;
	Line 257:     for (ii = 0; ii < 6; ++ii) mPlanes[ii].ABC = osg::Quat(0.0, osg::X_AXIS, mRotXYZ[1] * M_PI / 180, osg::Y_AXIS, 0.0, osg::Z_AXIS) * mPlanes[ii].ABC;
	Line 259:     for (ii = 0; ii < 6; ++ii) mPlanes[ii].ABC = osg::Quat(0.0, osg::X_AXIS, 0.0, osg::Y_AXIS, mRotXYZ[2] * M_PI / 180, osg::Z_AXIS) * mPlanes[ii].ABC;
	Line 259:     for (ii = 0; ii < 6; ++ii) mPlanes[ii].ABC = osg::Quat(0.0, osg::X_AXIS, 0.0, osg::Y_AXIS, mRotXYZ[2] * M_PI / 180, osg::Z_AXIS) * mPlanes[ii].ABC;
	Line 259:     for (ii = 0; ii < 6; ++ii) mPlanes[ii].ABC = osg::Quat(0.0, osg::X_AXIS, 0.0, osg::Y_AXIS, mRotXYZ[2] * M_PI / 180, osg::Z_AXIS) * mPlanes[ii].ABC;
	Line 259:     for (ii = 0; ii < 6; ++ii) mPlanes[ii].ABC = osg::Quat(0.0, osg::X_AXIS, 0.0, osg::Y_AXIS, mRotXYZ[2] * M_PI / 180, osg::Z_AXIS) * mPlanes[ii].ABC;
	Line 269:         for (ii=0; ii<4; ++ii) mBase[ii] = osg::Quat(mRotXYZ[0] * M_PI/180, osg::X_AXIS, 0.0, osg::Y_AXIS, 0.0, osg::Z_AXIS) * mBase[ii];
	Line 269:         for (ii=0; ii<4; ++ii) mBase[ii] = osg::Quat(mRotXYZ[0] * M_PI/180, osg::X_AXIS, 0.0, osg::Y_AXIS, 0.0, osg::Z_AXIS) * mBase[ii];
	Line 269:         for (ii=0; ii<4; ++ii) mBase[ii] = osg::Quat(mRotXYZ[0] * M_PI/180, osg::X_AXIS, 0.0, osg::Y_AXIS, 0.0, osg::Z_AXIS) * mBase[ii];
	Line 269:         for (ii=0; ii<4; ++ii) mBase[ii] = osg::Quat(mRotXYZ[0] * M_PI/180, osg::X_AXIS, 0.0, osg::Y_AXIS, 0.0, osg::Z_AXIS) * mBase[ii];
	Line 272:             mBase[ii] = osg::Quat(0.0, osg::X_AXIS, 0.0, osg::Y_AXIS, mRotXYZ[2] * M_PI/180, osg::Z_AXIS) * mBase[ii];
	Line 272:             mBase[ii] = osg::Quat(0.0, osg::X_AXIS, 0.0, osg::Y_AXIS, mRotXYZ[2] * M_PI/180, osg::Z_AXIS) * mBase[ii];
	Line 272:             mBase[ii] = osg::Quat(0.0, osg::X_AXIS, 0.0, osg::Y_AXIS, mRotXYZ[2] * M_PI/180, osg::Z_AXIS) * mBase[ii];
	Line 272:             mBase[ii] = osg::Quat(0.0, osg::X_AXIS, 0.0, osg::Y_AXIS, mRotXYZ[2] * M_PI/180, osg::Z_AXIS) * mBase[ii];
	Line 295:         for (ii=0; ii<6; ++ii) mPlanes[ii].ABC = osg::Quat(mRotXYZ[0] * M_PI/180, osg::X_AXIS, 0.0, osg::Y_AXIS, 0.0, osg::Z_AXIS) * mPlanes[ii].ABC;
	Line 295:         for (ii=0; ii<6; ++ii) mPlanes[ii].ABC = osg::Quat(mRotXYZ[0] * M_PI/180, osg::X_AXIS, 0.0, osg::Y_AXIS, 0.0, osg::Z_AXIS) * mPlanes[ii].ABC;
	Line 295:         for (ii=0; ii<6; ++ii) mPlanes[ii].ABC = osg::Quat(mRotXYZ[0] * M_PI/180, osg::X_AXIS, 0.0, osg::Y_AXIS, 0.0, osg::Z_AXIS) * mPlanes[ii].ABC;
	Line 295:         for (ii=0; ii<6; ++ii) mPlanes[ii].ABC = osg::Quat(mRotXYZ[0] * M_PI/180, osg::X_AXIS, 0.0, osg::Y_AXIS, 0.0, osg::Z_AXIS) * mPlanes[ii].ABC;
	Line 297:         for (ii=0; ii<6; ++ii) mPlanes[ii].ABC = osg::Quat(0.0, osg::X_AXIS, 0.0, osg::Y_AXIS, mRotXYZ[2] * M_PI/180, osg::Z_AXIS) * mPlanes[ii].ABC;
	Line 297:         for (ii=0; ii<6; ++ii) mPlanes[ii].ABC = osg::Quat(0.0, osg::X_AXIS, 0.0, osg::Y_AXIS, mRotXYZ[2] * M_PI/180, osg::Z_AXIS) * mPlanes[ii].ABC;
	Line 297:         for (ii=0; ii<6; ++ii) mPlanes[ii].ABC = osg::Quat(0.0, osg::X_AXIS, 0.0, osg::Y_AXIS, mRotXYZ[2] * M_PI/180, osg::Z_AXIS) * mPlanes[ii].ABC;
	Line 297:         for (ii=0; ii<6; ++ii) mPlanes[ii].ABC = osg::Quat(0.0, osg::X_AXIS, 0.0, osg::Y_AXIS, mRotXYZ[2] * M_PI/180, osg::Z_AXIS) * mPlanes[ii].ABC;
  D:\Development\psim\src\subview\ViewSpec.h (2 hits)
	Line 58:     osg::Vec3f mApex;
	Line 59:     osg::Vec3f mBase[4];
  D:\Development\psim\src\subview\ViewSpecPlane.h (1 hit)
	Line 14:     osg::Vec3f ABC;
  D:\Development\psim\src\subview\VlsAnimator.cpp (4 hits)
	Line 51:         osg::Vec3 position = vehicle->getVlsVentLaunchPt(cellSet, moduleNumber);
	Line 57:         params.setGeomDimensions(osg::Vec2(30, 30));
	Line 69:         params.setOrientation(osg::Vec3(0, 0, -90 * (M_PI / 180)));
	Line 73:         params.setOrientation(osg::Vec3(0, 0, 90 * (M_PI / 180)));
  D:\Development\psim\src\subview\VlsHatch.cpp (17 hits)
	Line 20: VlsHatch::VlsHatch(Vehicle* vehicle, osg::Geode* node) :
	Line 58:     osg::Vec3f position(node->computeBound().center());
	Line 59:     const osg::Vec3Array * normals = dynamic_cast<const osg::Vec3Array*> (dynamic_cast<osg::Geometry*> (node->getDrawable(0))->getNormalArray());
	Line 59:     const osg::Vec3Array * normals = dynamic_cast<const osg::Vec3Array*> (dynamic_cast<osg::Geometry*> (node->getDrawable(0))->getNormalArray());
	Line 59:     const osg::Vec3Array * normals = dynamic_cast<const osg::Vec3Array*> (dynamic_cast<osg::Geometry*> (node->getDrawable(0))->getNormalArray());
	Line 60:     osg::Vec3f orientation((*normals)[0].x(), (*normals)[0].y(), (*normals)[0].z());
	Line 63:     mPutMatrix = osg::Matrix::translate(-position) * osg::Matrix::rotate(orientation, osg::Vec3f(-1, 0, 0));
	Line 63:     mPutMatrix = osg::Matrix::translate(-position) * osg::Matrix::rotate(orientation, osg::Vec3f(-1, 0, 0));
	Line 63:     mPutMatrix = osg::Matrix::translate(-position) * osg::Matrix::rotate(orientation, osg::Vec3f(-1, 0, 0));
	Line 66:     mInvPutMatrix = osg::Matrix::rotate(osg::Vec3f(-1, 0, 0), orientation) * osg::Matrix::translate(position);
	Line 66:     mInvPutMatrix = osg::Matrix::rotate(osg::Vec3f(-1, 0, 0), orientation) * osg::Matrix::translate(position);
	Line 66:     mInvPutMatrix = osg::Matrix::rotate(osg::Vec3f(-1, 0, 0), orientation) * osg::Matrix::translate(position);
	Line 69: void VlsHatch::operator()(osg::Node* node, osg::NodeVisitor* nv)
	Line 69: void VlsHatch::operator()(osg::Node* node, osg::NodeVisitor* nv)
	Line 101:     osg::Matrix mTransform;
	Line 107:     mTransform.postMult(osg::Matrix::rotate(M_PI / 180.0 * (angle), 0.f, 1.f, 0.f));
	Line 112:     dynamic_cast<osg::MatrixTransform *> (node)->setMatrix(mTransform);
  D:\Development\psim\src\subview\VlsHatch.h (6 hits)
	Line 16: class VlsHatch : public osg::NodeCallback
	Line 26:     VlsHatch(Vehicle* vehicle, osg::Geode* node);
	Line 32:     virtual void operator()(osg::Node* node, osg::NodeVisitor* nv);
	Line 32:     virtual void operator()(osg::Node* node, osg::NodeVisitor* nv);
	Line 40:     osg::Matrix mPutMatrix;
	Line 41:     osg::Matrix mInvPutMatrix;
  D:\Development\psim\src\subview\VlsVent.cpp (17 hits)
	Line 20: VlsVent::VlsVent(Vehicle* vehicle, osg::Geode* node) :
	Line 54:     osg::Vec3f position(node->computeBound().center());
	Line 55:     const osg::Vec3Array * normals = dynamic_cast<const osg::Vec3Array*> (dynamic_cast<osg::Geometry*> (node->getDrawable(0))->getNormalArray());
	Line 55:     const osg::Vec3Array * normals = dynamic_cast<const osg::Vec3Array*> (dynamic_cast<osg::Geometry*> (node->getDrawable(0))->getNormalArray());
	Line 55:     const osg::Vec3Array * normals = dynamic_cast<const osg::Vec3Array*> (dynamic_cast<osg::Geometry*> (node->getDrawable(0))->getNormalArray());
	Line 56:     osg::Vec3f orientation((*normals)[0].x(), (*normals)[0].y(), (*normals)[0].z());
	Line 59:     mPutMatrix = osg::Matrix::translate(-position) * osg::Matrix::rotate(orientation, osg::Vec3f(-1, 0, 0));
	Line 59:     mPutMatrix = osg::Matrix::translate(-position) * osg::Matrix::rotate(orientation, osg::Vec3f(-1, 0, 0));
	Line 59:     mPutMatrix = osg::Matrix::translate(-position) * osg::Matrix::rotate(orientation, osg::Vec3f(-1, 0, 0));
	Line 61:     mInvPutMatrix = osg::Matrix::rotate(osg::Vec3f(-1, 0, 0), orientation) * osg::Matrix::translate(position);
	Line 61:     mInvPutMatrix = osg::Matrix::rotate(osg::Vec3f(-1, 0, 0), orientation) * osg::Matrix::translate(position);
	Line 61:     mInvPutMatrix = osg::Matrix::rotate(osg::Vec3f(-1, 0, 0), orientation) * osg::Matrix::translate(position);
	Line 64: void VlsVent::operator()(osg::Node* node, osg::NodeVisitor* nv)
	Line 64: void VlsVent::operator()(osg::Node* node, osg::NodeVisitor* nv)
	Line 101:     osg::Matrix mTransform;
	Line 108:     mTransform.postMult(osg::Matrix::rotate(M_PI / 180.0 * (angle), 0.f, 1.f, 0.f));
	Line 113:     dynamic_cast<osg::MatrixTransform *> (node)->setMatrix(mTransform);
  D:\Development\psim\src\subview\VlsVent.h (6 hits)
	Line 16: class VlsVent : public osg::NodeCallback
	Line 26:     VlsVent(Vehicle* vehicle, osg::Geode* node);
	Line 32:     virtual void operator()(osg::Node* node, osg::NodeVisitor* nv);
	Line 32:     virtual void operator()(osg::Node* node, osg::NodeVisitor* nv);
	Line 42:     osg::Matrix mPutMatrix;
	Line 43:     osg::Matrix mInvPutMatrix;
  D:\Development\psim\src\subview\Wake.cpp (65 hits)
	Line 56: Wake::Wake(Vehicle *assocVehicle, osg::Vec3 min, osg::Vec3 max, WakeType wakeType, bool wakeIsIR, bool wakeIsBacking) :
	Line 56: Wake::Wake(Vehicle *assocVehicle, osg::Vec3 min, osg::Vec3 max, WakeType wakeType, bool wakeIsIR, bool wakeIsBacking) :
	Line 59: normals(new osg::Vec3Array),
	Line 60: baseColors(new osg::Vec4Array),
	Line 61: baseCoords(new osg::Vec3Array),
	Line 62: baseCoordsCopy(new osg::Vec3Array),
	Line 63: baseTexCoords0(new osg::Vec2Array),
	Line 64: baseTexCoords1(new osg::Vec2Array),
	Line 65: tailColors(new osg::Vec4Array),
	Line 66: tailCoords(new osg::Vec3Array),
	Line 67: tailTexCoords(new osg::Vec2Array),
	Line 173:     curTailXYZ = osg::Vec3(xVal, yVal, zVal);
	Line 174:     storedTailXYZ = osg::Vec3(xVal, yVal, zVal);
	Line 206: void Wake::removeWake(osg::Group *root)
	Line 440:     curXYZ = osg::Vec3(subData->XYZ[0], subData->XYZ[1], subData->XYZ[2]);
	Line 441:     curTailXYZ = osg::Vec3(subData->XYZ[0] - X, subData->XYZ[1] + Y, subData->XYZ[2]);
	Line 542:     osg::Vec3 tmpVec3;
	Line 543:     osg::Matrixf multMat;
	Line 575:         osg::Vec3f coordsPosFront = (*baseCoordsCopy)[0];
	Line 576:         osg::Vec3f coordsPosBack = (*baseCoordsCopy)[1];
	Line 640:     osg::Matrixf wakePos;
	Line 642:     osg::Vec3 wakeTrans((float) curTailXYZ[0], (float) curTailXYZ[1], 0.f);
	Line 850: void Wake::manipMatrix(osg::Matrixf &res, float X, float Y, float H)
	Line 852:     osg::Matrixf rot = osg::Matrix::rotate(osg::inDegrees(H), 0.0f, 0.0f, 1.0f);
	Line 852:     osg::Matrixf rot = osg::Matrix::rotate(osg::inDegrees(H), 0.0f, 0.0f, 1.0f);
	Line 852:     osg::Matrixf rot = osg::Matrix::rotate(osg::inDegrees(H), 0.0f, 0.0f, 1.0f);
	Line 952:     osg::Matrixf wakePos;
	Line 954:     osg::Vec3 wakeTrans((float) curTailXYZ[0], (float) curTailXYZ[1], 0.f);
	Line 984:     (*normals)[0] = osg::Vec3(0.0f, 0.0f, 1.0f);
	Line 1007: void Wake::addWakeToOSG(osg::Group * root)
	Line 1009:     osg::ref_ptr<ProjWakeGeometry> projWakeGeom = getProjWakeGeom();
	Line 1010:     osg::ref_ptr<osg::Geode> projWakeGeode = getProjWakeGeode();
	Line 1010:     osg::ref_ptr<osg::Geode> projWakeGeode = getProjWakeGeode();
	Line 1016: void Wake::removeWakeFromOSG(osg::Group * root)
	Line 1023: osg::Texture* Wake::createProjTexture(int width, int height)
	Line 1025:     osg::Texture2D* texture = new osg::Texture2D();
	Line 1025:     osg::Texture2D* texture = new osg::Texture2D();
	Line 1029:     texture->setFilter(osg::Texture::MIN_FILTER, osg::Texture::LINEAR);
	Line 1029:     texture->setFilter(osg::Texture::MIN_FILTER, osg::Texture::LINEAR);
	Line 1030:     texture->setFilter(osg::Texture::MAG_FILTER, osg::Texture::LINEAR);
	Line 1030:     texture->setFilter(osg::Texture::MAG_FILTER, osg::Texture::LINEAR);
	Line 1031:     texture->setWrap(osg::Texture::WRAP_S, osg::Texture::CLAMP_TO_BORDER);
	Line 1031:     texture->setWrap(osg::Texture::WRAP_S, osg::Texture::CLAMP_TO_BORDER);
	Line 1032:     texture->setWrap(osg::Texture::WRAP_T, osg::Texture::CLAMP_TO_BORDER);
	Line 1032:     texture->setWrap(osg::Texture::WRAP_T, osg::Texture::CLAMP_TO_BORDER);
	Line 1033:     texture->setWrap(osg::Texture::WRAP_R, osg::Texture::CLAMP_TO_BORDER);
	Line 1033:     texture->setWrap(osg::Texture::WRAP_R, osg::Texture::CLAMP_TO_BORDER);
	Line 1034:     texture->setBorderColor(osg::Vec4(0., 0., 0., 0.));
	Line 1054:     osg::Vec3f contactLoc = mVehicle->getContactLoc();
	Line 1072:     osg::Vec3f bowWakePt = mVehicle->getBowWakePt();
	Line 1081:         osg::Vec3f curActiveMastLoc = mVehicle->getActiveMastLoc();
	Line 1087:         osg::Vec3f sailWakePt = mVehicle->getSailTopPt();
	Line 1130:     osg::Vec3f backingWakePt;
	Line 1331:         geo->lees_nearWakePosUniform->setElement(index, osg::Vec4f(dynWake_origin[0], dynWake_origin[1], dynWake_origin[2], dynWake_origin[3]));
	Line 1332:         geo->lees_nearWakeDirSizeUniform->setElement(index, osg::Vec4f(dynWake_dirSize[0], dynWake_dirSize[1], dynWake_dirSize[2], dynWake_dirSize[3]));
	Line 1334:         geo->lees_nearWakeFalloffsAftUniform->set(osg::Vec4f(wakeFalloffsAft[0], wakeFalloffsAft[1], wakeFalloffsAft[2], wakeFalloffsAft[3]));
	Line 1345: osg::Vec2f Wake::getDynWakePos() const
	Line 1347:     return osg::Vec2f(dynWake_origin[0], dynWake_origin[1]);
	Line 1365: osg::ref_ptr<ProjWakeGeometry> Wake::getProjWakeGeom()
	Line 1367:     static osg::ref_ptr<ProjWakeGeometry> wakeGeom = new ProjWakeGeometry; // singleton
	Line 1371: osg::ref_ptr<osg::Geode> Wake::getProjWakeGeode()
	Line 1371: osg::ref_ptr<osg::Geode> Wake::getProjWakeGeode()
	Line 1373:     static osg::ref_ptr<osg::Geode> geode = new osg::Geode; // singleton
	Line 1373:     static osg::ref_ptr<osg::Geode> geode = new osg::Geode; // singleton
	Line 1373:     static osg::ref_ptr<osg::Geode> geode = new osg::Geode; // singleton
  D:\Development\psim\src\subview\Wake.h (45 hits)
	Line 37:     osg::ref_ptr<osg::Vec3Array> normals;
	Line 37:     osg::ref_ptr<osg::Vec3Array> normals;
	Line 41:     osg::ref_ptr<osg::Vec4Array> baseColors;
	Line 41:     osg::ref_ptr<osg::Vec4Array> baseColors;
	Line 42:     osg::ref_ptr<osg::Vec3Array> baseCoords;
	Line 42:     osg::ref_ptr<osg::Vec3Array> baseCoords;
	Line 43:     osg::ref_ptr<osg::Vec3Array> baseCoordsCopy;
	Line 43:     osg::ref_ptr<osg::Vec3Array> baseCoordsCopy;
	Line 44:     osg::ref_ptr<osg::Vec2Array> baseTexCoords0;
	Line 44:     osg::ref_ptr<osg::Vec2Array> baseTexCoords0;
	Line 45:     osg::ref_ptr<osg::Vec2Array> baseTexCoords1;
	Line 45:     osg::ref_ptr<osg::Vec2Array> baseTexCoords1;
	Line 49:     osg::ref_ptr<osg::Vec4Array> tailColors;
	Line 49:     osg::ref_ptr<osg::Vec4Array> tailColors;
	Line 50:     osg::ref_ptr<osg::Vec3Array> tailCoords;
	Line 50:     osg::ref_ptr<osg::Vec3Array> tailCoords;
	Line 51:     osg::ref_ptr<osg::Vec2Array> tailTexCoords;
	Line 51:     osg::ref_ptr<osg::Vec2Array> tailTexCoords;
	Line 53:     osg::Vec2d oldLatLon;
	Line 55:     osg::Vec3f dimensions;
	Line 56:     osg::Vec3f vehicleMin;
	Line 57:     osg::Vec3f vehicleMax;
	Line 58:     osg::Vec3f curXYZ;
	Line 59:     osg::Vec3f curTailXYZ;
	Line 60:     osg::Vec3f storedTailXYZ;
	Line 61:     osg::Vec3f oldXYZ;
	Line 62:     osg::Vec3f storedXYZ;
	Line 63:     osg::Vec3f pivotOffset;
	Line 64:     osg::Vec3f deltaWorldCenter;
	Line 65:     osg::BoundingBox bbox;
	Line 130:     void manipMatrix(osg::Matrixf &res, float X, float Y, float H);
	Line 135:     osg::Vec2f getDynWakePos() const;
	Line 174:     void removeWake(osg::Group *root);
	Line 176:     void reconstruct(ObjectData *subCurData, osg::Vec3f &min, osg::Vec3f &max, int id, int wakeType);
	Line 176:     void reconstruct(ObjectData *subCurData, osg::Vec3f &min, osg::Vec3f &max, int id, int wakeType);
	Line 187:     Wake(Vehicle *assocVehicle, osg::Vec3 min, osg::Vec3 max, WakeType wakeType, bool wakeIsIR, bool wakeIsBacking);
	Line 187:     Wake(Vehicle *assocVehicle, osg::Vec3 min, osg::Vec3 max, WakeType wakeType, bool wakeIsIR, bool wakeIsBacking);
	Line 191:     static void addWakeToOSG(osg::Group *root);
	Line 192:     void removeWakeFromOSG(osg::Group *root);
	Line 198:     static osg::ref_ptr<ProjWakeGeometry> getProjWakeGeom();
	Line 200:     static osg::ref_ptr<osg::Geode> getProjWakeGeode();
	Line 200:     static osg::ref_ptr<osg::Geode> getProjWakeGeode();
	Line 202:     osg::Texture* createProjTexture(int width, int height);
	Line 236:     osg::ref_ptr<osg::Uniform> mLightCoeffUniform;
	Line 236:     osg::ref_ptr<osg::Uniform> mLightCoeffUniform;
  D:\Development\psim\src\subview\WakeCallback.cpp (10 hits)
	Line 22: extern osg::ref_ptr<osg::Camera> mainCamera;
	Line 22: extern osg::ref_ptr<osg::Camera> mainCamera;
	Line 30: void WakeCallback::operator()(osg::Node *node, osg::NodeVisitor *nv)
	Line 30: void WakeCallback::operator()(osg::Node *node, osg::NodeVisitor *nv)
	Line 140:         osg::Vec2 dXY = contact->getMovementVector();
	Line 213:     osg::Vec3f cameraPos, lookAt, up, buoyXYZ;
	Line 217:     osg::Vec2f viewdir = osg::Vec2f(lookAt[0] - cameraPos[0], lookAt[1] - cameraPos[1]);
	Line 217:     osg::Vec2f viewdir = osg::Vec2f(lookAt[0] - cameraPos[0], lookAt[1] - cameraPos[1]);
	Line 218:     osg::Vec2f buoypos = osg::Vec2f(buoyXYZ[0], buoyXYZ[1]);
	Line 218:     osg::Vec2f buoypos = osg::Vec2f(buoyXYZ[0], buoyXYZ[1]);
  D:\Development\psim\src\subview\WakeCallback.h (3 hits)
	Line 13: class WakeCallback : public osg::NodeCallback
	Line 17:     virtual void operator()(osg::Node *node, osg::NodeVisitor *nv);
	Line 17:     virtual void operator()(osg::Node *node, osg::NodeVisitor *nv);
  D:\Development\psim\src\subview\WakeManager.cpp (7 hits)
	Line 121: void WakeManager::setWakeCallback(osg::ref_ptr<osg::Group> root)
	Line 121: void WakeManager::setWakeCallback(osg::ref_ptr<osg::Group> root)
	Line 186:         osg::Vec4 falloffs = osg::Vec4(
	Line 186:         osg::Vec4 falloffs = osg::Vec4(
	Line 279:         bowWakeScale = osg::clampBetween(bowWakeScale, 0.0, 1.0);
	Line 340:     maxBowHeight = osg::clampBelow(maxBowHeight, 125.0);
	Line 343:     speed = osg::clampBelow(static_cast<double> (speed), 20.0);
  D:\Development\psim\src\subview\WakeManager.h (5 hits)
	Line 44:     osg::ref_ptr<osg::Group> wakesGrp;
	Line 44:     osg::ref_ptr<osg::Group> wakesGrp;
	Line 53:     void setWakeCallback(osg::ref_ptr<osg::Group> root);
	Line 53:     void setWakeCallback(osg::ref_ptr<osg::Group> root);
	Line 56:     void addWakeToOSG(osg::Group * root);
  D:\Development\psim\src\subview\WashOver.cpp (26 hits)
	Line 26: WashOver::WashOver(osg::Group * root) :
	Line 37:     mTextureRect = new osg::TextureRectangle;
	Line 40:     mTextureRect->setFilter(osg::Texture2D::MIN_FILTER, osg::Texture2D::LINEAR);
	Line 40:     mTextureRect->setFilter(osg::Texture2D::MIN_FILTER, osg::Texture2D::LINEAR);
	Line 41:     mTextureRect->setFilter(osg::Texture2D::MAG_FILTER, osg::Texture2D::LINEAR);
	Line 41:     mTextureRect->setFilter(osg::Texture2D::MAG_FILTER, osg::Texture2D::LINEAR);
	Line 44:     osg::Geode* geode = new osg::Geode();
	Line 44:     osg::Geode* geode = new osg::Geode();
	Line 47:     mQuadSwitch = new osg::Switch;
	Line 72:         mWashMap[ii] = new osg::Texture2D;
	Line 75:         //mWashMap[ii]->setWrap(osg::Texture::WRAP_S, osg::Texture::CLAMP);
	Line 75:         //mWashMap[ii]->setWrap(osg::Texture::WRAP_S, osg::Texture::CLAMP);
	Line 76:         //mWashMap[ii]->setWrap(osg::Texture::WRAP_T, osg::Texture::CLAMP);
	Line 76:         //mWashMap[ii]->setWrap(osg::Texture::WRAP_T, osg::Texture::CLAMP);
	Line 77:         //mWashMap[ii]->setWrap(osg::Texture::WRAP_R, osg::Texture::CLAMP);
	Line 77:         //mWashMap[ii]->setWrap(osg::Texture::WRAP_R, osg::Texture::CLAMP);
	Line 78:         mWashMap[ii]->setWrap(osg::Texture::WRAP_S, osg::Texture::REPEAT);
	Line 78:         mWashMap[ii]->setWrap(osg::Texture::WRAP_S, osg::Texture::REPEAT);
	Line 79:         mWashMap[ii]->setWrap(osg::Texture::WRAP_T, osg::Texture::REPEAT);
	Line 79:         mWashMap[ii]->setWrap(osg::Texture::WRAP_T, osg::Texture::REPEAT);
	Line 80:         mWashMap[ii]->setWrap(osg::Texture::WRAP_R, osg::Texture::REPEAT);
	Line 80:         mWashMap[ii]->setWrap(osg::Texture::WRAP_R, osg::Texture::REPEAT);
	Line 81:         mWashMap[ii]->setFilter(osg::Texture2D::MIN_FILTER, osg::Texture2D::LINEAR_MIPMAP_LINEAR);
	Line 81:         mWashMap[ii]->setFilter(osg::Texture2D::MIN_FILTER, osg::Texture2D::LINEAR_MIPMAP_LINEAR);
	Line 82:         mWashMap[ii]->setFilter(osg::Texture2D::MAG_FILTER, osg::Texture2D::LINEAR);
	Line 82:         mWashMap[ii]->setFilter(osg::Texture2D::MAG_FILTER, osg::Texture2D::LINEAR);
  D:\Development\psim\src\subview\WashOver.h (10 hits)
	Line 16:     WashOver(osg::Group * root);
	Line 25:     osg::ref_ptr<osg::Image> mWashMapImage[180];
	Line 25:     osg::ref_ptr<osg::Image> mWashMapImage[180];
	Line 26:     osg::ref_ptr<osg::Texture2D>mWashMap[180];
	Line 26:     osg::ref_ptr<osg::Texture2D>mWashMap[180];
	Line 27:     osg::ref_ptr<WashOverQuad> mQuad;
	Line 28:     osg::ref_ptr<osg::Switch> mQuadSwitch;
	Line 28:     osg::ref_ptr<osg::Switch> mQuadSwitch;
	Line 30:     osg::ref_ptr<osg::TextureRectangle> mTextureRect;
	Line 30:     osg::ref_ptr<osg::TextureRectangle> mTextureRect;
  D:\Development\psim\src\subview\WashOverQuad.cpp (38 hits)
	Line 37: WashOverQuad::WashOverQuad(osg::Texture2D *_WasMap, osg::TextureRectangle *_textureRect)
	Line 37: WashOverQuad::WashOverQuad(osg::Texture2D *_WasMap, osg::TextureRectangle *_textureRect)
	Line 40:     sProjectionMatrix = new osg::RefMatrix(osg::Matrix::ortho(-1.0, 1.0, -1.0, 1.0, -50.0, 50.0));
	Line 40:     sProjectionMatrix = new osg::RefMatrix(osg::Matrix::ortho(-1.0, 1.0, -1.0, 1.0, -50.0, 50.0));
	Line 41:     sModelviewMatrix = new osg::RefMatrix(osg::Matrixf::identity());
	Line 41:     sModelviewMatrix = new osg::RefMatrix(osg::Matrixf::identity());
	Line 46:     stateSet = new osg::StateSet;
	Line 48:     stateSet->setTextureAttributeAndModes(0, WasMap, osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);
	Line 48:     stateSet->setTextureAttributeAndModes(0, WasMap, osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);
	Line 49:     stateSet->setTextureAttributeAndModes(1, textureRect, osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);
	Line 49:     stateSet->setTextureAttributeAndModes(1, textureRect, osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);
	Line 50:     stateSet->addUniform(new osg::Uniform("washMap", 0));
	Line 51:     stateSet->addUniform(new osg::Uniform("washScene", 1));
	Line 53:     invScreenWidthHeightUniform = new osg::Uniform("invScreenWidthHeight", osg::Vec2(1.f / SubviewConfig::winWidth, 1.f / SubviewConfig::winHeight));
	Line 53:     invScreenWidthHeightUniform = new osg::Uniform("invScreenWidthHeight", osg::Vec2(1.f / SubviewConfig::winWidth, 1.f / SubviewConfig::winHeight));
	Line 56:     fadeUniform = new osg::Uniform("fade", 1.f);
	Line 58:     randOffUniform = new osg::Uniform("randOff", 0.f);
	Line 61:     oceanColorOffsetUniform = new osg::Uniform("oceanColorOffset", osg::Vec3(1.0, 1.0, 1.0));
	Line 61:     oceanColorOffsetUniform = new osg::Uniform("oceanColorOffset", osg::Vec3(1.0, 1.0, 1.0));
	Line 62:     lightCoeffUniform = new osg::Uniform("lightCoeff", 0.0f);
	Line 70:     osg::ref_ptr<osg::Program> program = new osg::Program;
	Line 70:     osg::ref_ptr<osg::Program> program = new osg::Program;
	Line 70:     osg::ref_ptr<osg::Program> program = new osg::Program;
	Line 72:     program->addShader(ShaderMaster::getInstance().createShader(osg::Shader::FRAGMENT, "washoverFrag.glsl"));
	Line 73:     stateSet->setAttributeAndModes(program.get(), osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);
	Line 73:     stateSet->setAttributeAndModes(program.get(), osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);
	Line 74:     stateSet->setRenderingHint(osg::StateSet::TRANSPARENT_BIN);
	Line 78: void WashOverQuad::drawImplementation(osg::RenderInfo& ri) const
	Line 84:     osg::Texture::TextureObject* textureObject = textureRect->getTextureObject(0);
	Line 125: osg::BoundingBox WashOverQuad::computeBound() const
	Line 127:     osg::BoundingBox bbox;
	Line 128:     bbox.expandBy(osg::Vec3(-10000.f, -10000.f, -10000.f));
	Line 129:     bbox.expandBy(osg::Vec3(10000.f, 10000.f, 10000.f));
	Line 141: void WashOverQuad::setWashMap(osg::Texture2D *map, float fade)
	Line 143:     invScreenWidthHeightUniform->set(osg::Vec2(1.f / SubviewConfig::winWidth, 1.f / SubviewConfig::winHeight));
	Line 146:     oceanColorOffsetUniform->set(osg::Vec3((float) Shared->ocData.offsetcolor.Red / 255.0, (float) Shared->ocData.offsetcolor.Green / 255.0, (float) Shared->ocData.offsetcolor.Blue / 255.0));
	Line 149:     stateSet->setTextureAttributeAndModes(0, map, osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);
	Line 149:     stateSet->setTextureAttributeAndModes(0, map, osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);
  D:\Development\psim\src\subview\WashOverQuad.h (27 hits)
	Line 24: class WashOverQuad : public osg::Geometry
	Line 29:     WashOverQuad(const WashOverQuad& WashOverQuad, const osg::CopyOp& copyop = osg::CopyOp::SHALLOW_COPY) :
	Line 29:     WashOverQuad(const WashOverQuad& WashOverQuad, const osg::CopyOp& copyop = osg::CopyOp::SHALLOW_COPY) :
	Line 30:     osg::Geometry(WashOverQuad, copyop)
	Line 37:     WashOverQuad(osg::Texture2D *_WasMap, osg::TextureRectangle *_textureRect);
	Line 37:     WashOverQuad(osg::Texture2D *_WasMap, osg::TextureRectangle *_textureRect);
	Line 38:     virtual void drawImplementation(osg::RenderInfo& ri) const;
	Line 39:     virtual osg::BoundingBox computeBound() const;
	Line 41:     void setWashMap(osg::Texture2D *map, float fade);
	Line 49:     osg::ref_ptr<osg::RefMatrix> sProjectionMatrix;
	Line 49:     osg::ref_ptr<osg::RefMatrix> sProjectionMatrix;
	Line 50:     osg::ref_ptr<osg::RefMatrix> sModelviewMatrix;
	Line 50:     osg::ref_ptr<osg::RefMatrix> sModelviewMatrix;
	Line 51:     osg::ref_ptr<osg::StateSet> stateSet;
	Line 51:     osg::ref_ptr<osg::StateSet> stateSet;
	Line 52:     osg::ref_ptr<osg::Uniform> invScreenWidthHeightUniform;
	Line 52:     osg::ref_ptr<osg::Uniform> invScreenWidthHeightUniform;
	Line 53:     osg::ref_ptr<osg::Uniform> fadeUniform;
	Line 53:     osg::ref_ptr<osg::Uniform> fadeUniform;
	Line 54:     osg::ref_ptr<osg::Uniform> randOffUniform;
	Line 54:     osg::ref_ptr<osg::Uniform> randOffUniform;
	Line 55:     osg::ref_ptr<osg::Uniform> oceanColorOffsetUniform;
	Line 55:     osg::ref_ptr<osg::Uniform> oceanColorOffsetUniform;
	Line 56:     osg::ref_ptr<osg::Uniform> lightCoeffUniform;
	Line 56:     osg::ref_ptr<osg::Uniform> lightCoeffUniform;
	Line 58:     osg::Texture2D *WasMap;
	Line 59:     osg::TextureRectangle *textureRect;
  D:\Development\psim\src\subview\WaveHeightApp.cpp (1 hit)
	Line 29: osg::Image* WaveHeightApp::getHeightImage()
  D:\Development\psim\src\subview\WaveHeightApp.h (2 hits)
	Line 21:     osg::Image* getHeightImage();
	Line 28:     osg::Image* mpHeightImageApp;
  D:\Development\psim\src\subview\WaveHeightBase.cpp (6 hits)
	Line 39:             mHeightImages[ii][jj] = new osg::Image;
	Line 68: float WaveHeightBase::getHeight(float *xyz, osg::Image& heightImage) const
	Line 71:     osg::Vec2f viewOrigin(Shared->viewOrigin[0], Shared->viewOrigin[1]);
	Line 72:     osg::Vec2f glVertex(xyz[0], xyz[1]);
	Line 73:     osg::Vec2f coord = viewOrigin + glVertex;
	Line 75:     osg::Vec2f uv = coord * IFFT_SIZE_INV;
  D:\Development\psim\src\subview\WaveHeightBase.h (3 hits)
	Line 23:     float getHeight(float *xyz, osg::Image& heightImage) const;
	Line 34:     osg::ref_ptr<osg::Image> mHeightImages[3][NUM_READERS + 2];
	Line 34:     osg::ref_ptr<osg::Image> mHeightImages[3][NUM_READERS + 2];
  D:\Development\psim\src\subview\WaveHeightCreate.cpp (7 hits)
	Line 97: osg::Image* WaveHeightCreate::getHeightImage() const
	Line 216: float WaveHeightCreate::phillipsSpectrum(const osg::Vec2f& K)
	Line 223:     float KdotW = K * osg::Vec2f(1.f, 0.f); // K*mWindDir;
	Line 309:     osg::Vec2f K;
	Line 353:     osg::Vec2f K;
	Line 354:     osg::Vec2f Kh0(0, 0);
	Line 500:     osg::Image* height_image = getHeightImage();
  D:\Development\psim\src\subview\WaveHeightCreate.h (5 hits)
	Line 27:     osg::Image* getHeightImage() const;
	Line 34:     osg::Image* mpHeightImageCreate;
	Line 44:     float phillipsSpectrum(const osg::Vec2f& K);
	Line 75:     std::vector< osg::Vec2f > Kh;
	Line 101:     //	osg::Vec2f mWindDir;
  D:\Development\psim\src\subview\WaveHeightUpdate.cpp (1 hit)
	Line 31: osg::Image* WaveHeightUpdate::getHeightImage()
  D:\Development\psim\src\subview\WaveHeightUpdate.h (2 hits)
	Line 21:     osg::Image* getHeightImage();
	Line 31:     osg::Image* mpHeightImageUpdate;
  D:\Development\psim\src\subview\WindscreenDisplay.cpp (13 hits)
	Line 23: WindscreenDisplay::WindscreenDisplay(osg::BoundingBox boundingBox, osg::ref_ptr<osg::Group> drawBox) :
	Line 23: WindscreenDisplay::WindscreenDisplay(osg::BoundingBox boundingBox, osg::ref_ptr<osg::Group> drawBox) :
	Line 23: WindscreenDisplay::WindscreenDisplay(osg::BoundingBox boundingBox, osg::ref_ptr<osg::Group> drawBox) :
	Line 34:     osg::Vec3 upperLeftCorner = mBoundingBox.corner(6);
	Line 45:     osg::Vec3 windscreenColor;
	Line 49:         windscreenColor = osg::Vec3(atoi(getenv("WINDSCREEN_TEXT_RED")),
	Line 64:             mWindscreenGeode = new osg::Geode();
	Line 67:             mWindscreenGeode->getOrCreateStateSet()->setAttributeAndModes(new osg::Program(),
	Line 68:                     osg::StateAttribute::ON | osg::StateAttribute::PROTECTED);
	Line 68:                     osg::StateAttribute::ON | osg::StateAttribute::PROTECTED);
	Line 75:             mWindscreenText[row][column]->getOrCreateStateSet()->setDataVariance(osg::Object::DYNAMIC);
	Line 80:             mWindscreenText[row][column]->setColor(osg::Vec4(windscreenColor[0] / 255.f,
	Line 87:             osg::Vec3 position = upperLeftCorner;
  D:\Development\psim\src\subview\WindscreenDisplay.h (9 hits)
	Line 15:     WindscreenDisplay(osg::BoundingBox boundingBox, osg::ref_ptr<osg::Group> drawBox);
	Line 15:     WindscreenDisplay(osg::BoundingBox boundingBox, osg::ref_ptr<osg::Group> drawBox);
	Line 15:     WindscreenDisplay(osg::BoundingBox boundingBox, osg::ref_ptr<osg::Group> drawBox);
	Line 24:     osg::BoundingBox mBoundingBox;
	Line 25:     osg::ref_ptr<osg::Group> mDrawBox;
	Line 25:     osg::ref_ptr<osg::Group> mDrawBox;
	Line 26:     osg::ref_ptr<osgText::Text> mWindscreenText[ROW_COUNT][COLUMN_COUNT];
	Line 28:     osg::ref_ptr<osg::Geode> mWindscreenGeode;
	Line 28:     osg::ref_ptr<osg::Geode> mWindscreenGeode;
  D:\Development\psim\src\subview\WindscreenUpdateCallback.cpp (4 hits)
	Line 24: void WindscreenUpdateCallback::operator()(osg::Node* node, osg::NodeVisitor* nv)
	Line 24: void WindscreenUpdateCallback::operator()(osg::Node* node, osg::NodeVisitor* nv)
	Line 26:     osg::Geode* geode = dynamic_cast<osg::Geode*> (node);
	Line 26:     osg::Geode* geode = dynamic_cast<osg::Geode*> (node);
  D:\Development\psim\src\subview\WindscreenUpdateCallback.h (3 hits)
	Line 16: class WindscreenUpdateCallback : public osg::NodeCallback
	Line 23:     virtual void operator()(osg::Node* node, osg::NodeVisitor* nv);
	Line 23:     virtual void operator()(osg::Node* node, osg::NodeVisitor* nv);
  D:\Development\psim\src\subview\XFormNodeCallback.cpp (11 hits)
	Line 47: XFormNodeCallback::XFormNodeCallback(int contactId, QueryContacts::MastAttribs attribs, osg::Vec3f mastWakePos, osg::Geode * node, Vehicle *vehicle, bool isLightMast)
	Line 47: XFormNodeCallback::XFormNodeCallback(int contactId, QueryContacts::MastAttribs attribs, osg::Vec3f mastWakePos, osg::Geode * node, Vehicle *vehicle, bool isLightMast)
	Line 61:     osg::Vec3f position(node->computeBound().center());
	Line 62:     mPutMatrix = osg::Matrix::translate(-position);
	Line 63:     mInvPutMatrix = osg::Matrix::translate(position);
	Line 94: void XFormNodeCallback::operator()(osg::Node * node, osg::NodeVisitor * nv)
	Line 94: void XFormNodeCallback::operator()(osg::Node * node, osg::NodeVisitor * nv)
	Line 126:         osg::Matrixf trans = osg::Matrixf::translate(0.f, 0.f, mHeight);
	Line 126:         osg::Matrixf trans = osg::Matrixf::translate(0.f, 0.f, mHeight);
	Line 129:         dynamic_cast<osg::MatrixTransform *> (node)->setMatrix(mTransform);
	Line 217: osg::Vec3f XFormNodeCallback::getActiveMastLoc()
  D:\Development\psim\src\subview\XFormNodeCallback.h (10 hits)
	Line 24: class XFormNodeCallback : public osg::NodeCallback
	Line 27:     XFormNodeCallback(int, QueryContacts::MastAttribs, osg::Vec3f, osg::Geode *, Vehicle *, bool isLightMast);
	Line 27:     XFormNodeCallback(int, QueryContacts::MastAttribs, osg::Vec3f, osg::Geode *, Vehicle *, bool isLightMast);
	Line 29:     virtual void operator()(osg::Node *, osg::NodeVisitor *);
	Line 29:     virtual void operator()(osg::Node *, osg::NodeVisitor *);
	Line 41:     osg::Vec3f getActiveMastLoc();
	Line 46:     osg::Matrix mPutMatrix; // puts back to world origin
	Line 47:     osg::Matrix mInvPutMatrix; // puts back to local origin
	Line 48:     osg::Matrix mTransform; // local transformation
	Line 58:     osg::Vec3f activeMastLoc;
Search "osg::" (0 hits in 0 files)
Search "OpenThreads::" (67 hits in 18 files)
  D:\Development\psim\src\subview\EffectsManager.h (1 hit)
	Line 134:     OpenThreads::Mutex rootUpdateMutex;
  D:\Development\psim\src\subview\GameBoard.cpp (16 hits)
	Line 65:     OpenThreads::ScopedLock<OpenThreads::Mutex> mlock(backgroundVehicleDeleteMutex);
	Line 65:     OpenThreads::ScopedLock<OpenThreads::Mutex> mlock(backgroundVehicleDeleteMutex);
	Line 106:             OpenThreads::ScopedLock<OpenThreads::Mutex> lock(backgroundVehicleLoadMutex);
	Line 106:             OpenThreads::ScopedLock<OpenThreads::Mutex> lock(backgroundVehicleLoadMutex);
	Line 124:             OpenThreads::ScopedLock<OpenThreads::Mutex> lock(backgroundVehicleLoadMutex);
	Line 124:             OpenThreads::ScopedLock<OpenThreads::Mutex> lock(backgroundVehicleLoadMutex);
	Line 138:                 OpenThreads::ScopedLock<OpenThreads::Mutex> lock(backgroundVehicleDeleteMutex);
	Line 138:                 OpenThreads::ScopedLock<OpenThreads::Mutex> lock(backgroundVehicleDeleteMutex);
	Line 516:     OpenThreads::ScopedLock<OpenThreads::Mutex> lock(backgroundVehicleLoadMutex);
	Line 516:     OpenThreads::ScopedLock<OpenThreads::Mutex> lock(backgroundVehicleLoadMutex);
	Line 570:     OpenThreads::ScopedLock<OpenThreads::Mutex> lock(backgroundVehicleDeleteMutex);
	Line 570:     OpenThreads::ScopedLock<OpenThreads::Mutex> lock(backgroundVehicleDeleteMutex);
	Line 658: OpenThreads::Mutex& GameBoard::getBackgroundVehicleLoadMutex()
	Line 663: OpenThreads::Mutex& GameBoard::getBackgroundVehicleDeleteMutex()
	Line 689:             OpenThreads::ScopedLock<OpenThreads::Mutex> lock(backgroundVehicleDeleteMutex);
	Line 689:             OpenThreads::ScopedLock<OpenThreads::Mutex> lock(backgroundVehicleDeleteMutex);
  D:\Development\psim\src\subview\GameBoard.h (4 hits)
	Line 41:     OpenThreads::Mutex backgroundVehicleDeleteMutex;
	Line 42:     OpenThreads::Mutex backgroundVehicleLoadMutex;
	Line 112:     OpenThreads::Mutex &getBackgroundVehicleLoadMutex();
	Line 114:     OpenThreads::Mutex &getBackgroundVehicleDeleteMutex();
  D:\Development\psim\src\subview\MiniBackgroundLoader.cpp (1 hit)
	Line 107:     OpenThreads::Mutex &backgroundVehicleLoadMutex = gameBoard->getBackgroundVehicleLoadMutex();
  D:\Development\psim\src\subview\MiniBackgroundLoader.h (1 hit)
	Line 23: class MiniBackgroundLoader : public OpenThreads::Thread
  D:\Development\psim\src\subview\OceanMesh.h (1 hit)
	Line 96:     OpenThreads::Mutex mDataMutex;
  D:\Development\psim\src\subview\OceanMeshGenerator.cpp (4 hits)
	Line 169:     OpenThreads::ScopedLock<OpenThreads::Mutex> lock(mSignalMutex);
	Line 169:     OpenThreads::ScopedLock<OpenThreads::Mutex> lock(mSignalMutex);
	Line 177:     OpenThreads::ScopedLock<OpenThreads::Mutex> lock(mSignalMutex);
	Line 177:     OpenThreads::ScopedLock<OpenThreads::Mutex> lock(mSignalMutex);
  D:\Development\psim\src\subview\OceanMeshGenerator.h (3 hits)
	Line 11: class OceanMeshGenerator : public OpenThreads::Thread
	Line 37:     OpenThreads::Mutex mSignalMutex;
	Line 38:     OpenThreads::Condition mSignalCond;
  D:\Development\psim\src\subview\ParticleGeom.h (1 hit)
	Line 33:     OpenThreads::Mutex deletionFinishRenderMutex;
  D:\Development\psim\src\subview\RootNodeCallback.cpp (1 hit)
	Line 867:     OpenThreads::Mutex &backgroundVehicleDeleteMutex = gameBoard->getBackgroundVehicleDeleteMutex();
  D:\Development\psim\src\subview\RootNodeCallback.h (1 hit)
	Line 72:     OpenThreads::Mutex vehicleAddListMutex;
  D:\Development\psim\src\subview\SubviewViewer.cpp (3 hits)
	Line 138:         //if (frameTime < minFrameTime) OpenThreads::Thread::microSleep(static_cast<unsigned int>(0.95*1000000.0*(minFrameTime-frameTime)));
	Line 139:         //if (frameTime < minFrameTime) OpenThreads::Thread::microSleep(static_cast<unsigned int>(1000000.0*(minFrameTime-frameTime)));
	Line 140:         if (elapsedTimeMicroSec < mMinFrameTimeMicroSec) OpenThreads::Thread::microSleep(mMinFrameTimeMicroSec - elapsedTimeMicroSec);
  D:\Development\psim\src\subview\ViewSpecShared.cpp (22 hits)
	Line 18:     OpenThreads::ScopedLock<OpenThreads::Mutex> lock(mMutex);
	Line 18:     OpenThreads::ScopedLock<OpenThreads::Mutex> lock(mMutex);
	Line 24:     OpenThreads::ScopedLock<OpenThreads::Mutex> lock(mMutex);
	Line 24:     OpenThreads::ScopedLock<OpenThreads::Mutex> lock(mMutex);
	Line 30:     OpenThreads::ScopedLock<OpenThreads::Mutex> lock(mMutex);
	Line 30:     OpenThreads::ScopedLock<OpenThreads::Mutex> lock(mMutex);
	Line 37:     OpenThreads::ScopedLock<OpenThreads::Mutex> lock(mMutex);
	Line 37:     OpenThreads::ScopedLock<OpenThreads::Mutex> lock(mMutex);
	Line 44:     OpenThreads::ScopedLock<OpenThreads::Mutex> lock(mMutex);
	Line 44:     OpenThreads::ScopedLock<OpenThreads::Mutex> lock(mMutex);
	Line 52:     OpenThreads::ScopedLock<OpenThreads::Mutex> lock(mMutex);
	Line 52:     OpenThreads::ScopedLock<OpenThreads::Mutex> lock(mMutex);
	Line 59:     OpenThreads::ScopedLock<OpenThreads::Mutex> lock(mMutex);
	Line 59:     OpenThreads::ScopedLock<OpenThreads::Mutex> lock(mMutex);
	Line 65:     OpenThreads::ScopedLock<OpenThreads::Mutex> lock(mMutex);
	Line 65:     OpenThreads::ScopedLock<OpenThreads::Mutex> lock(mMutex);
	Line 71:     OpenThreads::ScopedLock<OpenThreads::Mutex> lock(mMutex);
	Line 71:     OpenThreads::ScopedLock<OpenThreads::Mutex> lock(mMutex);
	Line 77:     OpenThreads::ScopedLock<OpenThreads::Mutex> lock(mMutex);
	Line 77:     OpenThreads::ScopedLock<OpenThreads::Mutex> lock(mMutex);
	Line 83:     OpenThreads::ScopedLock<OpenThreads::Mutex> lock(mMutex);
	Line 83:     OpenThreads::ScopedLock<OpenThreads::Mutex> lock(mMutex);
  D:\Development\psim\src\subview\ViewSpecShared.h (1 hit)
	Line 28:     OpenThreads::Mutex mMutex;
  D:\Development\psim\src\subview\WaveHeightApp.cpp (2 hits)
	Line 36:     OpenThreads::ScopedLock<OpenThreads::Mutex> lock(mSpinMutex);
	Line 36:     OpenThreads::ScopedLock<OpenThreads::Mutex> lock(mSpinMutex);
  D:\Development\psim\src\subview\WaveHeightBase.h (1 hit)
	Line 36:     OpenThreads::Mutex mSpinMutex;
  D:\Development\psim\src\subview\WaveHeightCreate.cpp (2 hits)
	Line 106:     OpenThreads::ScopedLock<OpenThreads::Mutex> lock(mSpinMutex);
	Line 106:     OpenThreads::ScopedLock<OpenThreads::Mutex> lock(mSpinMutex);
  D:\Development\psim\src\subview\WaveHeightUpdate.cpp (2 hits)
	Line 56:     OpenThreads::ScopedLock<OpenThreads::Mutex> lock(mSpinMutex);
	Line 56:     OpenThreads::ScopedLock<OpenThreads::Mutex> lock(mSpinMutex);
Search "OpenThreads::" (0 hits in 0 files)
